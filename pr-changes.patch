diff --git a/Cargo.toml b/Cargo.toml
index 8a487b612a..cc9cc28021 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -127,6 +127,8 @@ members = [
     "crates/project_symbols",
     "crates/prompt_store",
     "crates/proto",
+    "crates/pull_requests",
+    "crates/pull_requests_ui",
     "crates/recent_projects",
     "crates/refineable",
     "crates/refineable/derive_refineable",
@@ -211,7 +213,6 @@ members = [
     "extensions/slash-commands-example",
     "extensions/snippets",
     "extensions/test-extension",
-    "extensions/toml",
 
     #
     # Tooling
@@ -358,6 +359,8 @@ project_panel = { path = "crates/project_panel" }
 project_symbols = { path = "crates/project_symbols" }
 prompt_store = { path = "crates/prompt_store" }
 proto = { path = "crates/proto" }
+pull_requests = { path = "crates/pull_requests" }
+pull_requests_ui = { path = "crates/pull_requests_ui" }
 recent_projects = { path = "crates/recent_projects" }
 refineable = { path = "crates/refineable" }
 release_channel = { path = "crates/release_channel" }
@@ -462,9 +465,9 @@ aws-smithy-types = { version = "1.3.0", features = ["http-body-1-x"] }
 base64 = "0.22"
 bincode = "1.2.1"
 bitflags = "2.6.0"
-blade-graphics = { git = "https://github.com/kvark/blade", rev = "e0ec4e720957edd51b945b64dd85605ea54bcfe5" }
-blade-macros = { git = "https://github.com/kvark/blade", rev = "e0ec4e720957edd51b945b64dd85605ea54bcfe5" }
-blade-util = { git = "https://github.com/kvark/blade", rev = "e0ec4e720957edd51b945b64dd85605ea54bcfe5" }
+blade-graphics = { git = "https://github.com/kvark/blade", rev = "bfa594ea697d4b6326ea29f747525c85ecf933b9" }
+blade-macros = { git = "https://github.com/kvark/blade", rev = "bfa594ea697d4b6326ea29f747525c85ecf933b9" }
+blade-util = { git = "https://github.com/kvark/blade", rev = "bfa594ea697d4b6326ea29f747525c85ecf933b9" }
 blake3 = "1.5.3"
 bytes = "1.0"
 cargo_metadata = "0.19"
diff --git a/assets/keymaps/default-macos.json b/assets/keymaps/default-macos.json
index 954684c826..d2a850d5ae 100644
--- a/assets/keymaps/default-macos.json
+++ b/assets/keymaps/default-macos.json
@@ -378,6 +378,12 @@
       "ctrl--": "pane::GoBack"
     }
   },
+  {
+    "context": "AcpThread",
+    "bindings": {
+      "ctrl-shift-m": "agent::CycleCompletionMode"
+    }
+  },
   {
     "context": "AcpThread > Editor && !use_modifier_to_send",
     "use_key_equivalents": true,
@@ -686,6 +692,7 @@
       "cmd-shift-e": "project_panel::ToggleFocus",
       "cmd-shift-b": "outline_panel::ToggleFocus",
       "ctrl-shift-g": "git_panel::ToggleFocus",
+      "cmd-shift-g": "pull_requests::ToggleFocus",
       "cmd-shift-d": "debug_panel::ToggleFocus",
       "cmd-?": "agent::ToggleFocus",
       "cmd-alt-s": "workspace::SaveAll",
diff --git a/crates/git/src/hosting_provider.rs b/crates/git/src/hosting_provider.rs
index 5c11cb5504..0b53654169 100644
--- a/crates/git/src/hosting_provider.rs
+++ b/crates/git/src/hosting_provider.rs
@@ -206,7 +206,7 @@ impl GitHostingProviderRegistry {
     }
 }
 
-#[derive(Debug, PartialEq)]
+#[derive(Debug, PartialEq, Clone)]
 pub struct ParsedGitRemote {
     pub owner: Arc<str>,
     pub repo: Arc<str>,
diff --git a/crates/proto/proto/zed.proto b/crates/proto/proto/zed.proto
index 2222bdec08..4133b4b5ee 100644
--- a/crates/proto/proto/zed.proto
+++ b/crates/proto/proto/zed.proto
@@ -397,7 +397,9 @@ message Envelope {
 
         LspQuery lsp_query = 365;
         LspQueryResponse lsp_query_response = 366;
-        ToggleLspLogs toggle_lsp_logs = 367; // current max
+        ToggleLspLogs toggle_lsp_logs = 367;
+
+        UpdateUserSettings update_user_settings = 368; // current max
     }
 
     reserved 87 to 88;
diff --git a/crates/pull_requests/Cargo.toml b/crates/pull_requests/Cargo.toml
new file mode 100644
index 0000000000..10352cd190
--- /dev/null
+++ b/crates/pull_requests/Cargo.toml
@@ -0,0 +1,35 @@
+[package]
+name = "pull_requests"
+version = "0.1.0"
+edition = "2021"
+publish = false
+license = "GPL-3.0-or-later"
+
+[lints]
+workspace = true
+
+[lib]
+path = "src/pull_requests.rs"
+
+[dependencies]
+anyhow.workspace = true
+async-trait.workspace = true
+chrono.workspace = true
+collections.workspace = true
+dirs = "5.0"
+futures.workspace = true
+git.workspace = true
+git_hosting_providers.workspace = true
+gpui.workspace = true
+http_client.workspace = true
+log.workspace = true
+project.workspace = true
+serde.workspace = true
+serde_json.workspace = true
+settings.workspace = true
+smol.workspace = true
+util.workspace = true
+url.workspace = true
+
+[dev-dependencies]
+gpui = { workspace = true, features = ["test-support"] }
diff --git a/crates/pull_requests/src/api.rs b/crates/pull_requests/src/api.rs
new file mode 100644
index 0000000000..fe6b1fb6bd
--- /dev/null
+++ b/crates/pull_requests/src/api.rs
@@ -0,0 +1,282 @@
+use anyhow::Result;
+use async_trait::async_trait;
+use futures::AsyncReadExt;
+use git::ParsedGitRemote;
+use http_client::{AsyncBody, HttpClient, HttpRequestExt, Request};
+use serde::de::DeserializeOwned;
+use serde_json::json;
+use std::sync::Arc;
+use url::Url;
+
+use crate::models::{
+    CreatePullRequest, CreateReview, PullRequest, PullRequestComment, PullRequestDiff,
+    PullRequestReview, UpdatePullRequest,
+};
+
+#[async_trait]
+pub trait PullRequestApi: Send + Sync {
+    async fn list_pull_requests(
+        &self,
+        remote: &ParsedGitRemote,
+        state: Option<&str>,
+    ) -> Result<Vec<PullRequest>>;
+
+    async fn get_pull_request(&self, remote: &ParsedGitRemote, number: u32) -> Result<PullRequest>;
+
+    async fn create_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        pr: CreatePullRequest,
+    ) -> Result<PullRequest>;
+
+    async fn update_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        update: UpdatePullRequest,
+    ) -> Result<PullRequest>;
+
+    async fn get_pull_request_diff(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+    ) -> Result<PullRequestDiff>;
+
+    async fn list_pull_request_comments(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+    ) -> Result<Vec<PullRequestComment>>;
+
+    async fn create_review(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        review: CreateReview,
+    ) -> Result<PullRequestReview>;
+
+    async fn merge_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        commit_title: Option<String>,
+        commit_message: Option<String>,
+        merge_method: Option<&str>,
+    ) -> Result<()>;
+}
+
+pub struct GithubPrClient {
+    http_client: Arc<dyn HttpClient>,
+    token: Option<String>,
+    base_api_url: Url,
+}
+
+impl GithubPrClient {
+    pub fn new(http_client: Arc<dyn HttpClient>) -> Self {
+        let token = std::env::var("GITHUB_TOKEN").ok();
+        let base_api_url = Url::parse("https://api.github.com").unwrap();
+
+        Self {
+            http_client,
+            token,
+            base_api_url,
+        }
+    }
+
+    pub fn new_with_auth(http_client: Arc<dyn HttpClient>, token: Option<String>) -> Self {
+        let base_api_url = Url::parse("https://api.github.com").unwrap();
+
+        Self {
+            http_client,
+            token,
+            base_api_url,
+        }
+    }
+
+    pub fn with_base_url(mut self, base_url: Url) -> Self {
+        let host = base_url.host_str().unwrap_or("github.com");
+        if host == "github.com" {
+            self.base_api_url = Url::parse("https://api.github.com").unwrap();
+        } else {
+            self.base_api_url = Url::parse(&format!("https://api.{}", host))
+                .unwrap_or_else(|_| base_url.join("/api/v3/").unwrap());
+        }
+        self
+    }
+
+    pub fn with_token(mut self, token: String) -> Self {
+        self.token = Some(token);
+        self
+    }
+
+    async fn request<T: DeserializeOwned>(
+        &self,
+        method: &str,
+        path: &str,
+        body: Option<serde_json::Value>,
+    ) -> Result<T> {
+        let url = self.base_api_url.join(path)?;
+
+        let mut request = match method {
+            "GET" => Request::get(url.as_str()),
+            "POST" => Request::post(url.as_str()),
+            "PUT" => Request::put(url.as_str()),
+            "PATCH" => Request::patch(url.as_str()),
+            "DELETE" => Request::delete(url.as_str()),
+            _ => anyhow::bail!("Unsupported HTTP method: {}", method),
+        };
+
+        request = request
+            .header("Accept", "application/vnd.github+json")
+            .header("User-Agent", "zed-pull-requests")
+            .follow_redirects(http_client::RedirectPolicy::FollowAll);
+
+        if let Some(token) = &self.token {
+            request = request.header("Authorization", format!("Bearer {}", token));
+        }
+
+        let body = if let Some(json_body) = body {
+            AsyncBody::from(serde_json::to_vec(&json_body)?)
+        } else {
+            AsyncBody::default()
+        };
+
+        request = request.header("Content-Type", "application/json");
+
+        let mut response = self
+            .http_client
+            .send(request.body(body)?)
+            .await
+            .map_err(|e| anyhow::anyhow!("HTTP request failed: {}", e))?;
+
+        let mut body = Vec::new();
+        response.body_mut().read_to_end(&mut body).await?;
+
+        if !response.status().is_success() {
+            let error_text = String::from_utf8_lossy(&body);
+            anyhow::bail!("GitHub API error ({}): {}", response.status(), error_text);
+        }
+
+        serde_json::from_slice(&body)
+            .map_err(|e| anyhow::anyhow!("Failed to parse response: {}", e))
+    }
+}
+
+#[async_trait]
+impl PullRequestApi for GithubPrClient {
+    async fn list_pull_requests(
+        &self,
+        remote: &ParsedGitRemote,
+        state: Option<&str>,
+    ) -> Result<Vec<PullRequest>> {
+        let mut path = format!("repos/{}/{}/pulls", remote.owner, remote.repo);
+        if let Some(state) = state {
+            path.push_str(&format!("?state={}", state));
+        }
+        self.request("GET", &path, None).await
+    }
+
+    async fn get_pull_request(&self, remote: &ParsedGitRemote, number: u32) -> Result<PullRequest> {
+        let path = format!("repos/{}/{}/pulls/{}", remote.owner, remote.repo, number);
+        self.request("GET", &path, None).await
+    }
+
+    async fn create_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        pr: CreatePullRequest,
+    ) -> Result<PullRequest> {
+        let path = format!("repos/{}/{}/pulls", remote.owner, remote.repo);
+        let body = serde_json::to_value(pr)?;
+        self.request("POST", &path, Some(body)).await
+    }
+
+    async fn update_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        update: UpdatePullRequest,
+    ) -> Result<PullRequest> {
+        let path = format!("repos/{}/{}/pulls/{}", remote.owner, remote.repo, number);
+        let body = serde_json::to_value(update)?;
+        self.request("PATCH", &path, Some(body)).await
+    }
+
+    async fn get_pull_request_diff(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+    ) -> Result<PullRequestDiff> {
+        let path = format!(
+            "repos/{}/{}/pulls/{}/files",
+            remote.owner, remote.repo, number
+        );
+        let files = self.request("GET", &path, None).await?;
+        Ok(PullRequestDiff { files })
+    }
+
+    async fn list_pull_request_comments(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+    ) -> Result<Vec<PullRequestComment>> {
+        // Try to get issue comments (general discussion)
+        let path = format!(
+            "repos/{}/{}/issues/{}/comments",
+            remote.owner, remote.repo, number
+        );
+        
+        // Use a custom request that handles both arrays and error objects
+        match self.request::<Vec<PullRequestComment>>("GET", &path, None).await {
+            Ok(comments) => Ok(comments),
+            Err(e) => {
+                // If it fails, log the error and return empty array
+                log::warn!("Failed to fetch PR comments for #{}: {}", number, e);
+                Ok(vec![])
+            }
+        }
+    }
+
+    async fn create_review(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        review: CreateReview,
+    ) -> Result<PullRequestReview> {
+        let path = format!(
+            "repos/{}/{}/pulls/{}/reviews",
+            remote.owner, remote.repo, number
+        );
+        let body = serde_json::to_value(review)?;
+        self.request("POST", &path, Some(body)).await
+    }
+
+    async fn merge_pull_request(
+        &self,
+        remote: &ParsedGitRemote,
+        number: u32,
+        commit_title: Option<String>,
+        commit_message: Option<String>,
+        merge_method: Option<&str>,
+    ) -> Result<()> {
+        let path = format!(
+            "repos/{}/{}/pulls/{}/merge",
+            remote.owner, remote.repo, number
+        );
+
+        let mut body = json!({});
+        if let Some(title) = commit_title {
+            body["commit_title"] = json!(title);
+        }
+        if let Some(message) = commit_message {
+            body["commit_message"] = json!(message);
+        }
+        if let Some(method) = merge_method {
+            body["merge_method"] = json!(method);
+        }
+
+        self.request::<serde_json::Value>("PUT", &path, Some(body))
+            .await?;
+        Ok(())
+    }
+}
diff --git a/crates/pull_requests/src/auth.rs b/crates/pull_requests/src/auth.rs
new file mode 100644
index 0000000000..9538b33446
--- /dev/null
+++ b/crates/pull_requests/src/auth.rs
@@ -0,0 +1,381 @@
+use anyhow::{anyhow, Result};
+use gpui::{App, BorrowAppContext, Context, EventEmitter, Global};
+use serde::{Deserialize, Serialize};
+use url::Url;
+
+/// GitHub authentication state
+#[derive(Clone)]
+pub struct GithubAuth {
+    token: Option<String>,
+    user: Option<GithubUser>,
+    enterprise_url: Option<Url>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct GithubUser {
+    pub id: u64,
+    pub login: String,
+    pub name: Option<String>,
+    pub email: Option<String>,
+    pub avatar_url: String,
+}
+
+impl Global for GithubAuth {}
+
+impl GithubAuth {
+    pub fn init(cx: &mut App) {
+        // Try to load token from multiple sources in order of preference:
+        // 1. Environment variable (for CI/temporary override)
+        // 2. Saved token file in Zed config directory
+        // 3. Git credentials (as last resort, may cause hanging)
+        let token = std::env::var("GITHUB_TOKEN")
+            .ok()
+            .or_else(|| Self::load_saved_token())
+            .or_else(|| Self::load_from_git_credentials());
+
+        cx.set_global(Self {
+            token: token.clone(),
+            user: None,
+            enterprise_url: None,
+        });
+
+        // If we have a token from environment, save it for future use
+        if let Some(token) = token {
+            if std::env::var("GITHUB_TOKEN").is_ok() {
+                Self::save_token(&token);
+            }
+        }
+    }
+
+    fn get_token_file_path() -> std::path::PathBuf {
+        let config_dir = dirs::config_dir()
+            .unwrap_or_else(|| std::path::PathBuf::from("~/.config"));
+        config_dir.join("zed").join(".github_token")
+    }
+
+    fn save_token(token: &str) {
+        use std::fs;
+        use std::os::unix::fs::PermissionsExt;
+        
+        let token_path = Self::get_token_file_path();
+        
+        // Create directory if it doesn't exist
+        if let Some(parent) = token_path.parent() {
+            let _ = fs::create_dir_all(parent);
+        }
+        
+        // Write token with restricted permissions (600)
+        if let Ok(_) = fs::write(&token_path, token) {
+            if let Ok(metadata) = fs::metadata(&token_path) {
+                let mut permissions = metadata.permissions();
+                permissions.set_mode(0o600);
+                let _ = fs::set_permissions(&token_path, permissions);
+            }
+            log::info!("GitHub token saved to persistent storage");
+        }
+    }
+
+    fn load_saved_token() -> Option<String> {
+        use std::fs;
+        
+        let token_path = Self::get_token_file_path();
+        
+        match fs::read_to_string(&token_path) {
+            Ok(token) => {
+                let token = token.trim().to_string();
+                if !token.is_empty() {
+                    log::info!("Loaded GitHub token from persistent storage");
+                    Some(token)
+                } else {
+                    None
+                }
+            }
+            Err(_) => None
+        }
+    }
+
+    fn load_from_git_credentials() -> Option<String> {
+        use std::io::Write;
+        use std::process::{Command, Stdio};
+        use std::time::Duration;
+
+        // Try to get GitHub token from git credential helper with timeout
+        let mut child = Command::new("git")
+            .args(&["credential", "fill"])
+            .stdin(Stdio::piped())
+            .stdout(Stdio::piped())
+            .stderr(Stdio::null())
+            .spawn()
+            .ok()?;
+
+        if let Some(stdin) = child.stdin.as_mut() {
+            // Request credentials for github.com
+            if stdin
+                .write_all(b"protocol=https\nhost=github.com\n\n")
+                .is_err()
+            {
+                // Kill the process if write fails
+                let _ = child.kill();
+                return None;
+            }
+        }
+
+        // Use a timeout to prevent hanging
+        let output = match child.wait_with_output() {
+            Ok(output) if output.status.success() => output,
+            _ => return None,
+        };
+
+        // Parse the output to get the password (token)
+        let output_str = String::from_utf8(output.stdout).ok()?;
+        for line in output_str.lines() {
+            if let Some(token) = line.strip_prefix("password=") {
+                return Some(token.to_string());
+            }
+        }
+
+        None
+    }
+
+    pub fn trigger_git_login(cx: &mut App) -> anyhow::Result<()> {
+        use std::process::Command;
+
+        // Check if GitHub CLI is available
+        let gh_available = Command::new("gh")
+            .arg("--version")
+            .output()
+            .map(|o| o.status.success())
+            .unwrap_or(false);
+
+        if gh_available {
+            // Use GitHub CLI for authentication with required scopes
+            // repo: Full control of private repositories (needed for PR operations)
+            // read:user: Read user profile data
+            Command::new("gh")
+                .args(&["auth", "login", "--web", "--scopes", "repo,read:user"])
+                .spawn()?;
+
+            // TODO: After login completes, reload credentials
+            // This would need to be done asynchronously or via a refresh action
+        } else {
+            // Fall back to opening GitHub token page with required scopes
+            let url = "https://github.com/settings/tokens/new?scopes=repo,read:user&description=Zed%20Pull%20Requests";
+            cx.open_url(&url);
+        }
+
+        Ok(())
+    }
+
+    pub fn global(cx: &App) -> &Self {
+        cx.global::<Self>()
+    }
+
+    pub fn update_global<F, R>(cx: &mut App, f: F) -> R
+    where
+        F: FnOnce(&mut Self, &mut App) -> R,
+    {
+        cx.update_global::<Self, _>(f)
+    }
+
+    pub fn refresh_credentials(cx: &mut App) {
+        if let Some(token) = Self::load_from_git_credentials() {
+            Self::update_global(cx, |auth, _cx| {
+                auth.set_token(token);
+            });
+        }
+    }
+
+    pub fn token(&self) -> Option<&str> {
+        self.token.as_deref()
+    }
+
+    pub fn user(&self) -> Option<&GithubUser> {
+        self.user.as_ref()
+    }
+
+    pub fn is_authenticated(&self) -> bool {
+        self.token.is_some()
+    }
+
+    pub fn set_token(&mut self, token: String) {
+        self.token = Some(token);
+    }
+
+    pub fn clear_token(&mut self) {
+        self.token = None;
+        self.user = None;
+    }
+
+    pub fn set_user(&mut self, user: GithubUser) {
+        self.user = Some(user);
+    }
+
+    pub fn set_enterprise_url(&mut self, url: Option<Url>) {
+        self.enterprise_url = url;
+    }
+
+    pub fn enterprise_url(&self) -> Option<&Url> {
+        self.enterprise_url.as_ref()
+    }
+}
+
+/// Authentication dialog for GitHub
+pub struct GithubAuthDialog {
+    token_input: String,
+    enterprise_url_input: String,
+    is_enterprise: bool,
+    error_message: Option<String>,
+    is_validating: bool,
+}
+
+impl GithubAuthDialog {
+    pub fn new() -> Self {
+        Self {
+            token_input: String::new(),
+            enterprise_url_input: String::new(),
+            is_enterprise: false,
+            error_message: None,
+            is_validating: false,
+        }
+    }
+
+    pub fn authenticate(&mut self, cx: &mut Context<Self>) {
+        if self.token_input.is_empty() {
+            // Try to trigger git login instead
+            if let Err(e) = GithubAuth::trigger_git_login(cx) {
+                self.error_message = Some(format!("Failed to trigger login: {}", e));
+            } else {
+                self.error_message =
+                    Some("Please complete GitHub login in your browser".to_string());
+            }
+            cx.notify();
+            return;
+        }
+
+        self.is_validating = true;
+        self.error_message = None;
+        cx.notify();
+
+        let token = self.token_input.clone();
+        let enterprise_url = if self.is_enterprise {
+            Url::parse(&self.enterprise_url_input).ok()
+        } else {
+            None
+        };
+
+        cx.spawn(async move |this, cx| {
+            // Validate token by making a test API call
+            let validation_result = validate_token(&token, enterprise_url.as_ref()).await;
+
+            this.update(cx, |dialog, cx| {
+                dialog.is_validating = false;
+
+                match validation_result {
+                    Ok(user) => {
+                        // Save the token and user info
+                        GithubAuth::update_global(cx, |auth, _cx| {
+                            auth.set_token(token);
+                            auth.set_user(user);
+                            auth.set_enterprise_url(enterprise_url);
+                        });
+
+                        // Close the dialog
+                        cx.emit(AuthDialogEvent::Authenticated);
+                    }
+                    Err(e) => {
+                        dialog.error_message = Some(format!("Authentication failed: {}", e));
+                    }
+                }
+                cx.notify();
+            })?;
+
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach_and_log_err(cx);
+    }
+}
+
+impl EventEmitter<AuthDialogEvent> for GithubAuthDialog {}
+
+pub enum AuthDialogEvent {
+    Authenticated,
+    Cancelled,
+}
+
+async fn validate_token(token: &str, enterprise_url: Option<&Url>) -> Result<GithubUser> {
+    use http_client::{HttpClient, Request};
+
+    let base_url = if let Some(url) = enterprise_url {
+        format!("{}/api/v3", url)
+    } else {
+        "https://api.github.com".to_string()
+    };
+
+    let url = format!("{}/user", base_url);
+
+    // This is a placeholder - we need to get the HTTP client from the workspace
+    // For now, just return an error
+    return Err(anyhow!("Token validation not yet implemented"));
+
+    // TODO: Implement actual validation when we have access to HTTP client
+    // let request = Request::get(&url)
+    //     .header("Authorization", format!("Bearer {}", token))
+    //     .header("Accept", "application/vnd.github+json")
+    //     .header("User-Agent", "zed-pull-requests");
+    //
+    // let mut response = client
+    //     .send(request.body(http_client::AsyncBody::default())?)
+    //     .await?;
+    //
+    // if !response.status().is_success() {
+    //     return Err(anyhow!(
+    //         "Invalid token or API error: {}",
+    //         response.status()
+    //     ));
+    // }
+    //
+    // let mut body = Vec::new();
+    // futures::AsyncReadExt::read_to_end(&mut response.body_mut(), &mut body).await?;
+    //
+    // let user: GithubUser = serde_json::from_slice(&body)?;
+    // Ok(user)
+}
+
+/// Settings for GitHub integration
+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
+pub struct GithubSettings {
+    pub enterprise_url: Option<String>,
+    pub default_merge_method: MergeMethod,
+    pub auto_refresh_interval: u64, // seconds
+    pub show_draft_prs: bool,
+}
+
+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "snake_case")]
+pub enum MergeMethod {
+    Merge,
+    Squash,
+    Rebase,
+}
+
+impl Default for GithubSettings {
+    fn default() -> Self {
+        Self {
+            enterprise_url: None,
+            default_merge_method: MergeMethod::Merge,
+            auto_refresh_interval: 300, // 5 minutes
+            show_draft_prs: true,
+        }
+    }
+}
+
+// Add trait implementation for detach_and_log_err
+trait TaskExt {
+    fn detach_and_log_err(self, cx: &mut gpui::Context<GithubAuthDialog>);
+}
+
+impl TaskExt for gpui::Task<anyhow::Result<()>> {
+    fn detach_and_log_err(self, _cx: &mut gpui::Context<GithubAuthDialog>) {
+        self.detach();
+    }
+}
diff --git a/crates/pull_requests/src/models.rs b/crates/pull_requests/src/models.rs
new file mode 100644
index 0000000000..363ae4affb
--- /dev/null
+++ b/crates/pull_requests/src/models.rs
@@ -0,0 +1,303 @@
+use chrono::{DateTime, Utc};
+use serde::{Deserialize, Serialize};
+use url::Url;
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PullRequest {
+    pub number: u32,
+    pub id: u64,
+    pub title: String,
+    pub body: Option<String>,
+    pub state: PullRequestState,
+    pub html_url: Url,
+    pub user: User,
+    pub created_at: DateTime<Utc>,
+    pub updated_at: DateTime<Utc>,
+    pub merged_at: Option<DateTime<Utc>>,
+    pub closed_at: Option<DateTime<Utc>>,
+    pub head: GitReference,
+    pub base: GitReference,
+    #[serde(default)]
+    pub labels: Vec<Label>,
+    #[serde(default)]
+    pub assignees: Vec<User>,
+    #[serde(default)]
+    pub requested_reviewers: Vec<User>,
+    #[serde(default)]
+    pub draft: bool,
+    pub mergeable: Option<bool>,
+    pub mergeable_state: Option<String>,
+    #[serde(default)]
+    pub commits: u32,
+    #[serde(default)]
+    pub additions: u32,
+    #[serde(default)]
+    pub deletions: u32,
+    #[serde(default)]
+    pub changed_files: u32,
+    #[serde(default)]
+    pub comments: u32,
+    #[serde(default)]
+    pub review_comments: u32,
+    #[serde(default)]
+    pub reviews: Vec<PullRequestReview>,
+    #[serde(default)]
+    pub checks: CheckStatus,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "lowercase")]
+pub enum PullRequestState {
+    Open,
+    Closed,
+    Merged,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct User {
+    pub id: u64,
+    pub login: String,
+    pub avatar_url: Option<Url>,
+    pub html_url: Option<Url>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct GitReference {
+    pub label: Option<String>,
+    #[serde(rename = "ref")]
+    pub ref_name: String,
+    pub sha: String,
+    pub user: Option<User>,
+    pub repo: Option<Repository>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct Repository {
+    pub id: u64,
+    pub name: String,
+    pub full_name: String,
+    pub owner: User,
+    pub html_url: Url,
+    pub clone_url: Option<Url>,
+    pub ssh_url: Option<String>,
+    pub default_branch: Option<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct Label {
+    pub id: u64,
+    pub name: String,
+    pub color: String,
+    pub description: Option<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PullRequestReview {
+    pub id: u64,
+    pub user: User,
+    pub body: Option<String>,
+    pub state: ReviewState,
+    pub submitted_at: Option<DateTime<Utc>>,
+    #[serde(default)]
+    pub comments: Vec<ReviewComment>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
+pub enum ReviewState {
+    Pending,
+    Commented,
+    Approved,
+    ChangesRequested,
+    Dismissed,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct ReviewComment {
+    pub id: u64,
+    pub body: Option<String>,
+    pub path: Option<String>,
+    pub line: Option<u32>,
+    pub start_line: Option<u32>,
+    pub side: Option<CommentSide>,
+    pub user: User,
+    pub created_at: DateTime<Utc>,
+    pub updated_at: DateTime<Utc>,
+    pub in_reply_to_id: Option<u64>,
+    pub pull_request_review_id: Option<u64>,
+    pub diff_hunk: Option<String>,
+    pub original_line: Option<u32>,
+    pub original_start_line: Option<u32>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "UPPERCASE")]
+pub enum CommentSide {
+    Left,
+    Right,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct PullRequestComment {
+    pub id: u64,
+    pub body: Option<String>,
+    pub user: User,
+    pub created_at: DateTime<Utc>,
+    pub updated_at: DateTime<Utc>,
+    #[serde(default)]
+    pub reactions: ReactionSummary,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
+pub struct ReactionSummary {
+    #[serde(default)]
+    pub total_count: u32,
+    #[serde(rename = "+1", default)]
+    pub plus_one: u32,
+    #[serde(rename = "-1", default)]
+    pub minus_one: u32,
+    #[serde(default)]
+    pub laugh: u32,
+    #[serde(default)]
+    pub hooray: u32,
+    #[serde(default)]
+    pub confused: u32,
+    #[serde(default)]
+    pub heart: u32,
+    #[serde(default)]
+    pub rocket: u32,
+    #[serde(default)]
+    pub eyes: u32,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
+pub struct CheckStatus {
+    #[serde(default)]
+    pub state: CheckState,
+    #[serde(default)]
+    pub total_count: u32,
+    #[serde(default)]
+    pub statuses: Vec<Status>,
+    #[serde(default)]
+    pub check_runs: Vec<CheckRun>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
+#[serde(rename_all = "lowercase")]
+pub enum CheckState {
+    #[default]
+    Pending,
+    Success,
+    Failure,
+    Error,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct Status {
+    pub id: u64,
+    pub state: CheckState,
+    pub description: Option<String>,
+    pub target_url: Option<Url>,
+    pub context: String,
+    pub created_at: DateTime<Utc>,
+    pub updated_at: DateTime<Utc>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct CheckRun {
+    pub id: u64,
+    pub name: String,
+    pub status: CheckRunStatus,
+    pub conclusion: Option<CheckRunConclusion>,
+    pub started_at: DateTime<Utc>,
+    pub completed_at: Option<DateTime<Utc>>,
+    pub html_url: Url,
+    pub details_url: Option<Url>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "lowercase")]
+pub enum CheckRunStatus {
+    Queued,
+    InProgress,
+    Completed,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "snake_case")]
+pub enum CheckRunConclusion {
+    Success,
+    Failure,
+    Neutral,
+    Cancelled,
+    Skipped,
+    TimedOut,
+    ActionRequired,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct CreatePullRequest {
+    pub title: String,
+    pub body: String,
+    pub head: String,
+    pub base: String,
+    pub draft: bool,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct UpdatePullRequest {
+    pub title: Option<String>,
+    pub body: Option<String>,
+    pub state: Option<PullRequestState>,
+    pub base: Option<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct CreateReview {
+    pub body: String,
+    pub event: ReviewEvent,
+    pub comments: Vec<CreateReviewComment>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
+pub enum ReviewEvent {
+    Approve,
+    RequestChanges,
+    Comment,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct CreateReviewComment {
+    pub path: String,
+    pub line: Option<u32>,
+    pub side: Option<CommentSide>,
+    pub body: String,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct PullRequestDiff {
+    pub files: Vec<DiffFile>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct DiffFile {
+    pub filename: String,
+    pub status: FileStatus,
+    pub additions: u32,
+    pub deletions: u32,
+    pub changes: u32,
+    pub patch: Option<String>,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+#[serde(rename_all = "lowercase")]
+pub enum FileStatus {
+    Added,
+    Removed,
+    Modified,
+    Renamed,
+    Copied,
+    Changed,
+    Unchanged,
+}
diff --git a/crates/pull_requests/src/pull_requests.rs b/crates/pull_requests/src/pull_requests.rs
new file mode 100644
index 0000000000..f4269b0e1f
--- /dev/null
+++ b/crates/pull_requests/src/pull_requests.rs
@@ -0,0 +1,161 @@
+pub mod api;
+pub mod auth;
+pub mod models;
+pub mod store;
+
+use anyhow::Result;
+use git::ParsedGitRemote;
+use gpui::{App, Context, Entity, EventEmitter};
+use project::Project;
+use std::sync::Arc;
+
+pub use api::{GithubPrClient, PullRequestApi};
+pub use auth::{GithubAuth, GithubAuthDialog, GithubSettings};
+pub use models::{
+    CheckStatus, CreatePullRequest, PullRequest, PullRequestComment, PullRequestReview, PullRequestState,
+    ReviewComment, ReviewState,
+};
+pub use store::PullRequestStore;
+
+pub fn init(cx: &mut App) {
+    auth::GithubAuth::init(cx);
+    store::init(cx);
+}
+
+fn parse_github_remote(url: &str) -> Option<ParsedGitRemote> {
+    // Handle both SSH and HTTPS GitHub URLs
+    // SSH: git@github.com:owner/repo.git
+    // HTTPS: https://github.com/owner/repo.git or https://github.com/owner/repo
+
+    if url.starts_with("git@github.com:") {
+        // SSH format
+        let path = url.strip_prefix("git@github.com:")?;
+        let path = path.strip_suffix(".git").unwrap_or(path);
+        let parts: Vec<&str> = path.split('/').collect();
+        if parts.len() == 2 {
+            return Some(ParsedGitRemote {
+                owner: parts[0].into(),
+                repo: parts[1].into(),
+            });
+        }
+    } else if url.contains("github.com/") {
+        // HTTPS format
+        let start = url.find("github.com/")? + "github.com/".len();
+        let path = &url[start..];
+        let path = path.strip_suffix(".git").unwrap_or(path);
+        let parts: Vec<&str> = path.split('/').collect();
+        if parts.len() >= 2 {
+            return Some(ParsedGitRemote {
+                owner: parts[0].into(),
+                repo: parts[1].into(),
+            });
+        }
+    }
+
+    None
+}
+
+pub struct PullRequestManager {
+    project: Entity<Project>,
+    store: Entity<PullRequestStore>,
+    api_client: Arc<dyn PullRequestApi>,
+    _subscriptions: Vec<gpui::Subscription>,
+}
+
+impl PullRequestManager {
+    pub fn new_with_store(
+        project: Entity<Project>,
+        store: Entity<PullRequestStore>,
+        api_client: Arc<dyn PullRequestApi>,
+        cx: &mut Context<Self>,
+    ) -> Self {
+        let subscriptions = vec![cx.subscribe(&store, Self::on_store_event)];
+
+        Self {
+            project,
+            store,
+            api_client,
+            _subscriptions: subscriptions,
+        }
+    }
+
+    pub fn store(&self) -> &Entity<PullRequestStore> {
+        &self.store
+    }
+
+    pub fn refresh_pull_requests(&mut self, cx: &mut Context<Self>) -> anyhow::Result<()> {
+        let remote = self.get_current_remote(cx)?;
+        self.store
+            .update(cx, |store, cx| store.fetch_pull_requests(remote, cx))
+    }
+
+    pub fn checkout_pull_request(
+        &mut self,
+        pr_number: u32,
+        cx: &mut Context<Self>,
+    ) -> anyhow::Result<()> {
+        self.store
+            .update(cx, |store, cx| store.checkout_pull_request(pr_number, cx))
+    }
+
+    pub fn update_api_client(&mut self, api_client: Arc<dyn PullRequestApi>, cx: &mut Context<Self>) {
+        self.api_client = api_client.clone();
+        self.store
+            .update(cx, |store, _cx| store.update_api_client(api_client));
+    }
+
+    pub fn api_client(&self) -> Arc<dyn PullRequestApi> {
+        self.api_client.clone()
+    }
+
+    pub fn get_current_remote(&self, cx: &App) -> Result<ParsedGitRemote> {
+        // Get the git store from the project
+        let git_store = self.project.read(cx).git_store();
+        let repositories = git_store.read(cx).repositories();
+
+        // Get the first repository with a remote URL
+        for (_id, repo) in repositories {
+            let snapshot = repo.read(cx).snapshot();
+            if let Some(remote_url) = &snapshot.remote_origin_url {
+                // Parse the remote URL to extract owner and repo
+                if let Some(parsed) = parse_github_remote(remote_url) {
+                    return Ok(parsed);
+                }
+            }
+        }
+
+        // Fallback to Zed repo if no git remote found
+        Ok(ParsedGitRemote {
+            owner: "zed-industries".into(),
+            repo: "zed".into(),
+        })
+    }
+
+    fn on_store_event(
+        &mut self,
+        _store: Entity<PullRequestStore>,
+        event: &PullRequestStoreEvent,
+        cx: &mut Context<Self>,
+    ) {
+        match event {
+            PullRequestStoreEvent::PullRequestsUpdated => {
+                cx.notify();
+            }
+            PullRequestStoreEvent::ActivePullRequestChanged => {
+                cx.notify();
+            }
+        }
+    }
+}
+
+impl EventEmitter<PullRequestManagerEvent> for PullRequestManager {}
+
+pub enum PullRequestManagerEvent {
+    PullRequestsRefreshed,
+    PullRequestCheckedOut(u32),
+}
+
+pub enum PullRequestStoreEvent {
+    PullRequestsUpdated,
+    ActivePullRequestChanged,
+}
diff --git a/crates/pull_requests/src/store.rs b/crates/pull_requests/src/store.rs
new file mode 100644
index 0000000000..6ee9e5d2a7
--- /dev/null
+++ b/crates/pull_requests/src/store.rs
@@ -0,0 +1,227 @@
+use anyhow::Result;
+use collections::HashMap;
+use git::ParsedGitRemote;
+use gpui::{App, Context, EventEmitter, Task};
+use std::sync::Arc;
+
+use crate::api::PullRequestApi;
+use crate::models::{PullRequest, PullRequestState};
+use crate::PullRequestStoreEvent;
+
+pub fn init(_cx: &mut App) {}
+
+pub struct PullRequestStore {
+    api_client: Arc<dyn PullRequestApi>,
+    pull_requests: HashMap<u32, PullRequest>,
+    active_pr: Option<u32>,
+    loading: bool,
+    pub error: Option<String>,
+}
+
+impl PullRequestStore {
+    pub fn new(api_client: Arc<dyn PullRequestApi>, _cx: &mut Context<Self>) -> Self {
+        Self {
+            api_client,
+            pull_requests: HashMap::default(),
+            active_pr: None,
+            loading: false,
+            error: None,
+        }
+    }
+
+    pub fn pull_requests(&self) -> Vec<&PullRequest> {
+        let mut prs: Vec<_> = self.pull_requests.values().collect();
+        prs.sort_by_key(|pr| std::cmp::Reverse(pr.updated_at));
+        prs
+    }
+
+    pub fn get_pull_request(&self, number: u32) -> Option<&PullRequest> {
+        self.pull_requests.get(&number)
+    }
+
+    pub fn update_pull_request(&mut self, pr: PullRequest) {
+        self.pull_requests.insert(pr.number, pr);
+    }
+
+    pub fn active_pull_request(&self) -> Option<&PullRequest> {
+        self.active_pr.and_then(|num| self.pull_requests.get(&num))
+    }
+
+    pub fn is_loading(&self) -> bool {
+        self.loading
+    }
+
+    pub fn error(&self) -> Option<&str> {
+        self.error.as_deref()
+    }
+
+    pub fn update_api_client(&mut self, api_client: Arc<dyn PullRequestApi>) {
+        self.api_client = api_client;
+    }
+
+    pub fn fetch_pull_requests(
+        &mut self,
+        remote: ParsedGitRemote,
+        cx: &mut Context<Self>,
+    ) -> Result<()> {
+        if self.loading {
+            return Ok(());
+        }
+
+        self.loading = true;
+        self.error = None;
+        cx.notify();
+
+        let api_client = self.api_client.clone();
+
+        cx.spawn(async move |this, cx| {
+            let result = api_client.list_pull_requests(&remote, Some("open")).await;
+
+            this.update(cx, |store, cx| {
+                store.loading = false;
+
+                match result {
+                    Ok(prs) => {
+                        store.pull_requests.clear();
+                        // First, insert all PRs with basic data
+                        for pr in prs {
+                            store.pull_requests.insert(pr.number, pr);
+                        }
+                        store.error = None;
+                        cx.emit(PullRequestStoreEvent::PullRequestsUpdated);
+                        cx.notify();
+                        
+                        // Then fetch full details for each PR to get accurate comment counts
+                        let pr_numbers: Vec<u32> = store.pull_requests.keys().copied().collect();
+                        log::info!("Fetching full details for {} PRs to get comment counts", pr_numbers.len());
+                        for pr_number in pr_numbers {
+                            let api_client = api_client.clone();
+                            let remote = ParsedGitRemote {
+                                owner: remote.owner.clone(),
+                                repo: remote.repo.clone(),
+                            };
+                            cx.spawn(async move |this, cx| {
+                                log::info!("Fetching full details for PR #{}", pr_number);
+                                if let Ok(full_pr) = api_client.get_pull_request(&remote, pr_number).await {
+                                    log::info!("Got PR #{} with {} comments", pr_number, full_pr.comments + full_pr.review_comments);
+                                    this.update(cx, |store, cx| {
+                                        store.update_pull_request(full_pr);
+                                        cx.notify();
+                                    })?;
+                                }
+                                Ok::<(), anyhow::Error>(())
+                            })
+                            .detach();
+                        }
+                    }
+                    Err(e) => {
+                        store.error = Some(format!("Failed to fetch pull requests: {}", e));
+                        log::error!("Failed to fetch pull requests: {}", e);
+                        cx.notify();
+                    }
+                }
+            })?;
+
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach_and_log_err(cx);
+
+        Ok(())
+    }
+
+    pub fn fetch_pull_request(
+        &mut self,
+        remote: ParsedGitRemote,
+        number: u32,
+        cx: &mut Context<Self>,
+    ) -> Task<Result<()>> {
+        let api_client = self.api_client.clone();
+
+        cx.spawn(async move |this, cx| {
+            let pr = api_client.get_pull_request(&remote, number).await?;
+
+            this.update(cx, |store, cx| {
+                store.pull_requests.insert(number, pr);
+                cx.emit(PullRequestStoreEvent::PullRequestsUpdated);
+                cx.notify();
+            })?;
+
+            Ok::<(), anyhow::Error>(())
+        })
+    }
+
+    pub fn set_active_pull_request(&mut self, number: Option<u32>, cx: &mut Context<Self>) {
+        if self.active_pr != number {
+            self.active_pr = number;
+            cx.emit(PullRequestStoreEvent::ActivePullRequestChanged);
+            cx.notify();
+        }
+    }
+
+    pub fn checkout_pull_request(&mut self, pr_number: u32, cx: &mut Context<Self>) -> Result<()> {
+        let pr = self
+            .pull_requests
+            .get(&pr_number)
+            .ok_or_else(|| anyhow::anyhow!("Pull request {} not found", pr_number))?;
+
+        let branch_name = pr.head.ref_name.clone();
+
+        cx.spawn(async move |this, cx| {
+            smol::process::Command::new("git")
+                .arg("fetch")
+                .arg("origin")
+                .arg(&format!("pull/{}/head:{}", pr_number, branch_name))
+                .output()
+                .await?;
+
+            smol::process::Command::new("git")
+                .arg("checkout")
+                .arg(&branch_name)
+                .output()
+                .await?;
+
+            this.update(cx, |store, cx| {
+                store.set_active_pull_request(Some(pr_number), cx);
+            })?;
+
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach_and_log_err(cx);
+
+        Ok(())
+    }
+
+    pub fn filter_pull_requests(&self, filter: PullRequestFilter) -> Vec<&PullRequest> {
+        self.pull_requests()
+            .into_iter()
+            .filter(|pr| match &filter {
+                PullRequestFilter::All => true,
+                PullRequestFilter::Open => pr.state == PullRequestState::Open,
+                PullRequestFilter::Closed => pr.state == PullRequestState::Closed,
+                PullRequestFilter::Merged => pr.state == PullRequestState::Merged,
+                PullRequestFilter::Draft => pr.draft,
+                PullRequestFilter::ReadyForReview => !pr.draft,
+                PullRequestFilter::Author(login) => pr.user.login == *login,
+                PullRequestFilter::Assignee(login) => {
+                    pr.assignees.iter().any(|a| a.login == *login)
+                }
+                PullRequestFilter::Label(label) => pr.labels.iter().any(|l| l.name == *label),
+            })
+            .collect()
+    }
+}
+
+impl EventEmitter<PullRequestStoreEvent> for PullRequestStore {}
+
+#[derive(Clone, Debug)]
+pub enum PullRequestFilter {
+    All,
+    Open,
+    Closed,
+    Merged,
+    Draft,
+    ReadyForReview,
+    Author(String),
+    Assignee(String),
+    Label(String),
+}
diff --git a/crates/pull_requests_ui/Cargo.toml b/crates/pull_requests_ui/Cargo.toml
new file mode 100644
index 0000000000..6d4f10130c
--- /dev/null
+++ b/crates/pull_requests_ui/Cargo.toml
@@ -0,0 +1,38 @@
+[package]
+name = "pull_requests_ui"
+version = "0.1.0"
+edition = "2021"
+publish = false
+license = "GPL-3.0-or-later"
+
+[lints]
+workspace = true
+
+[lib]
+path = "src/pull_requests_ui.rs"
+
+[dependencies]
+anyhow.workspace = true
+chrono.workspace = true
+collections.workspace = true
+editor.workspace = true
+fs.workspace = true
+futures.workspace = true
+git.workspace = true
+gpui.workspace = true
+language.workspace = true
+log.workspace = true
+menu.workspace = true
+project.workspace = true
+pull_requests.workspace = true
+schemars.workspace = true
+serde.workspace = true
+settings.workspace = true
+theme.workspace = true
+ui.workspace = true
+util.workspace = true
+workspace.workspace = true
+zed_actions.workspace = true
+
+[dev-dependencies]
+gpui = { workspace = true, features = ["test-support"] }
diff --git a/crates/pull_requests_ui/src/create_pr_modal.rs b/crates/pull_requests_ui/src/create_pr_modal.rs
new file mode 100644
index 0000000000..60bd67f265
--- /dev/null
+++ b/crates/pull_requests_ui/src/create_pr_modal.rs
@@ -0,0 +1,293 @@
+use anyhow::Result;
+use editor::Editor;
+use gpui::{
+    actions, div, px, rems, App, Context, DismissEvent, Entity, EventEmitter,
+    FocusHandle, Focusable, InteractiveElement, IntoElement, ParentElement, Render,
+    SharedString, StatefulInteractiveElement, Styled, Task, VisualContext,
+    WeakEntity, Window,
+};
+use pull_requests::{CreatePullRequest, PullRequestManager};
+use settings::Settings;
+use theme::ActiveTheme;
+use ui::{
+    h_flex, prelude::*, v_flex, Button, ButtonStyle, Checkbox, Color, FluentBuilder,
+    Label, LabelCommon, LabelSize, Modal, ModalHeader,
+};
+use workspace::Workspace;
+
+actions!(
+    create_pr,
+    [SubmitPullRequest, CancelCreatePr, ToggleDraft, SelectBaseBranch]
+);
+
+pub struct CreatePrModal {
+    manager: Entity<PullRequestManager>,
+    title_editor: View<Editor>,
+    description_editor: View<Editor>,
+    base_branch: String,
+    head_branch: String,
+    is_draft: bool,
+    is_submitting: bool,
+    error_message: Option<String>,
+    focus_handle: FocusHandle,
+}
+
+impl CreatePrModal {
+    pub fn new(
+        manager: Entity<PullRequestManager>,
+        workspace: &mut Workspace,
+        window: &mut Window,
+        cx: &mut Context<Self>,
+    ) -> Self {
+        let focus_handle = cx.focus_handle();
+        
+        // Create editors for title and description
+        let title_editor = cx.new_view(|cx| {
+            let mut editor = Editor::single_line(cx);
+            editor.set_placeholder_text("Pull request title", cx);
+            editor
+        });
+        
+        let description_editor = cx.new_view(|cx| {
+            let mut editor = Editor::multi_line(cx);
+            editor.set_placeholder_text(
+                "Describe your changes\n\n## What does this PR do?\n\n## Screenshots (if applicable)",
+                cx,
+            );
+            editor
+        });
+
+        // Get current branch info
+        let (base_branch, head_branch) = Self::get_branch_info(&manager, cx);
+
+        Self {
+            manager,
+            title_editor,
+            description_editor,
+            base_branch,
+            head_branch,
+            is_draft: false,
+            is_submitting: false,
+            error_message: None,
+            focus_handle,
+        }
+    }
+
+    fn get_branch_info(manager: &Entity<PullRequestManager>, cx: &App) -> (String, String) {
+        // Get current branch from git
+        // For now, use defaults
+        ("main".to_string(), "feature-branch".to_string())
+    }
+
+    fn submit(&mut self, _: &SubmitPullRequest, cx: &mut Context<Self>) {
+        if self.is_submitting {
+            return;
+        }
+
+        let title = self.title_editor.read(cx).text(cx).to_string();
+        let description = self.description_editor.read(cx).text(cx).to_string();
+
+        if title.trim().is_empty() {
+            self.error_message = Some("Title is required".to_string());
+            cx.notify();
+            return;
+        }
+
+        self.is_submitting = true;
+        self.error_message = None;
+        cx.notify();
+
+        let manager = self.manager.clone();
+        let base = self.base_branch.clone();
+        let head = self.head_branch.clone();
+        let is_draft = self.is_draft;
+
+        cx.spawn(|this, mut cx| async move {
+            let result = cx
+                .update(|cx| {
+                    manager.update(cx, |manager, cx| {
+                        let remote = manager.get_current_remote(cx)?;
+                        let pr_data = CreatePullRequest {
+                            title,
+                            body: description,
+                            head,
+                            base,
+                            draft: is_draft,
+                        };
+                        
+                        let api = manager.api_client();
+                        cx.background_executor().spawn(async move {
+                            api.create_pull_request(&remote, pr_data).await
+                        })
+                    })
+                })?
+                .await;
+
+            this.update(&mut cx, |modal, cx| {
+                modal.is_submitting = false;
+                
+                match result {
+                    Ok(pr) => {
+                        // Success! Close modal and refresh PR list
+                        cx.emit(DismissEvent);
+                        
+                        // Refresh the PR list
+                        modal.manager.update(cx, |manager, cx| {
+                            manager.refresh_pull_requests(cx)
+                        });
+                    }
+                    Err(e) => {
+                        modal.error_message = Some(format!("Failed to create PR: {}", e));
+                    }
+                }
+                cx.notify();
+            })?;
+
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach_and_log_err(cx);
+    }
+
+    fn cancel(&mut self, _: &CancelCreatePr, cx: &mut Context<Self>) {
+        cx.emit(DismissEvent);
+    }
+
+    fn toggle_draft(&mut self, _: &ToggleDraft, cx: &mut Context<Self>) {
+        self.is_draft = !self.is_draft;
+        cx.notify();
+    }
+}
+
+impl Render for CreatePrModal {
+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
+        let theme = cx.theme();
+        
+        Modal::new("create-pr-modal", Some(self.focus_handle.clone()))
+            .header(ModalHeader::new("Create Pull Request"))
+            .section(
+                v_flex()
+                    .gap_4()
+                    .p_4()
+                    .child(
+                        v_flex()
+                            .gap_1()
+                            .child(Label::new("Title").size(LabelSize::Small))
+                            .child(
+                                div()
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .rounded_md()
+                                    .p_2()
+                                    .child(self.title_editor.clone()),
+                            ),
+                    )
+                    .child(
+                        v_flex()
+                            .gap_1()
+                            .child(Label::new("Description").size(LabelSize::Small))
+                            .child(
+                                div()
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .rounded_md()
+                                    .p_2()
+                                    .min_h(px(200.0))
+                                    .child(self.description_editor.clone()),
+                            ),
+                    )
+                    .child(
+                        h_flex()
+                            .gap_4()
+                            .child(
+                                v_flex()
+                                    .gap_1()
+                                    .flex_1()
+                                    .child(Label::new("Base").size(LabelSize::Small))
+                                    .child(
+                                        Button::new("base-branch", self.base_branch.clone())
+                                            .style(ButtonStyle::Subtle)
+                                            .full_width(),
+                                    ),
+                            )
+                            .child(
+                                v_flex()
+                                    .gap_1()
+                                    .flex_1()
+                                    .child(Label::new("Compare").size(LabelSize::Small))
+                                    .child(
+                                        Button::new("head-branch", self.head_branch.clone())
+                                            .style(ButtonStyle::Subtle)
+                                            .full_width()
+                                            .disabled(true),
+                                    ),
+                            ),
+                    )
+                    .child(
+                        h_flex()
+                            .gap_2()
+                            .child(
+                                Checkbox::new(
+                                    "draft-pr",
+                                    if self.is_draft {
+                                        ui::ToggleState::Selected
+                                    } else {
+                                        ui::ToggleState::Unselected
+                                    },
+                                )
+                                .on_click(cx.listener(|this, _, cx| {
+                                    this.toggle_draft(&ToggleDraft, cx);
+                                })),
+                            )
+                            .child(Label::new("Create as draft").size(LabelSize::Small)),
+                    )
+                    .when_some(self.error_message.as_ref(), |this, error| {
+                        this.child(
+                            div()
+                                .p_2()
+                                .rounded_md()
+                                .bg(theme.status().error_background)
+                                .child(Label::new(error.clone()).color(Color::Error)),
+                        )
+                    }),
+            )
+            .footer(
+                h_flex()
+                    .gap_2()
+                    .justify_end()
+                    .child(
+                        Button::new("cancel", "Cancel")
+                            .style(ButtonStyle::Subtle)
+                            .on_click(cx.listener(|this, _, cx| {
+                                this.cancel(&CancelCreatePr, cx);
+                            })),
+                    )
+                    .child(
+                        Button::new("create", "Create Pull Request")
+                            .style(ButtonStyle::Filled)
+                            .disabled(self.is_submitting)
+                            .on_click(cx.listener(|this, _, cx| {
+                                this.submit(&SubmitPullRequest, cx);
+                            })),
+                    ),
+            )
+    }
+}
+
+impl EventEmitter<DismissEvent> for CreatePrModal {}
+
+impl Focusable for CreatePrModal {
+    fn focus_handle(&self, _cx: &App) -> FocusHandle {
+        self.focus_handle.clone()
+    }
+}
+
+// Extension trait for Task
+trait TaskExt {
+    fn detach_and_log_err(self, cx: &mut Context<CreatePrModal>);
+}
+
+impl TaskExt for Task<Result<()>> {
+    fn detach_and_log_err(self, _cx: &mut Context<CreatePrModal>) {
+        self.detach();
+    }
+}
\ No newline at end of file
diff --git a/crates/pull_requests_ui/src/pr_detail_panel.rs b/crates/pull_requests_ui/src/pr_detail_panel.rs
new file mode 100644
index 0000000000..c54cd3df78
--- /dev/null
+++ b/crates/pull_requests_ui/src/pr_detail_panel.rs
@@ -0,0 +1,524 @@
+use anyhow::Result;
+use chrono::{DateTime, Local, Utc};
+use gpui::{
+    actions, div, px, rems, App, ClipboardItem, Context, Entity, EventEmitter, FocusHandle,
+    Focusable, InteractiveElement, IntoElement, ParentElement, Render, SharedString,
+    StatefulInteractiveElement, Styled, Task, TextStyle, Window,
+};
+use menu::{Cancel, Confirm};
+use pull_requests::{
+    PullRequest, PullRequestComment, PullRequestManager, PullRequestReview, PullRequestState,
+    ReviewState,
+};
+use settings::Settings;
+use theme::ActiveTheme;
+use ui::{
+    h_flex, prelude::*, v_flex, Avatar, Button, ButtonStyle, Clickable, Color, FluentBuilder, Icon,
+    IconButton, IconName, IconSize, Label, LabelCommon, LabelSize,
+};
+use workspace::Workspace;
+
+actions!(
+    pr_detail_panel,
+    [
+        ApprovePullRequest,
+        RequestChanges,
+        SubmitComment,
+        MergePullRequest,
+        ClosePullRequest,
+        RefreshDetails,
+        OpenDiff,
+        OpenInBrowser,
+    ]
+);
+
+pub struct PullRequestDetailPanel {
+    manager: Entity<PullRequestManager>,
+    pull_request: Option<PullRequest>,
+    comments: Vec<PullRequestComment>,
+    reviews: Vec<PullRequestReview>,
+    focus_handle: FocusHandle,
+    comment_draft: String,
+    review_comment_draft: String,
+    is_submitting: bool,
+    show_review_form: bool,
+    _subscriptions: Vec<gpui::Subscription>,
+}
+
+impl PullRequestDetailPanel {
+    pub fn new(
+        manager: Entity<PullRequestManager>,
+        workspace: &Workspace,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) -> Self {
+        let focus_handle = cx.focus_handle();
+        let subscriptions =
+            vec![cx.subscribe(&manager.read(cx).store().clone(), Self::on_store_event)];
+
+        Self {
+            manager,
+            pull_request: None,
+            comments: Vec::new(),
+            reviews: Vec::new(),
+            focus_handle,
+            comment_draft: String::new(),
+            review_comment_draft: String::new(),
+            is_submitting: false,
+            show_review_form: false,
+            _subscriptions: subscriptions,
+        }
+    }
+
+    pub fn set_pull_request(&mut self, pr: PullRequest, cx: &mut Context<Self>) {
+        self.pull_request = Some(pr.clone());
+        self.load_details(cx);
+        cx.notify();
+    }
+
+    fn load_details(&mut self, cx: &mut Context<Self>) {
+        if let Some(pr) = &self.pull_request {
+            let pr_number = pr.number;
+            let manager = self.manager.clone();
+
+            cx.spawn(async move |this, cx| {
+                // Load comments and reviews
+                // TODO: Implement API calls to fetch comments and reviews
+
+                this.update(cx, |panel, cx| {
+                    // Update UI with fetched data
+                    cx.notify();
+                })?;
+
+                Ok::<(), anyhow::Error>(())
+            })
+            .detach_and_log_err(cx);
+        }
+    }
+
+    fn on_store_event(
+        &mut self,
+        _store: Entity<pull_requests::PullRequestStore>,
+        _event: &pull_requests::PullRequestStoreEvent,
+        cx: &mut Context<Self>,
+    ) {
+        cx.notify();
+    }
+
+    fn submit_comment(&mut self, _: &SubmitComment, cx: &mut Context<Self>) {
+        if self.comment_draft.trim().is_empty() {
+            return;
+        }
+
+        if let Some(pr) = &self.pull_request {
+            let comment_text = self.comment_draft.clone();
+            let pr_number = pr.number;
+            let manager = self.manager.clone();
+
+            self.is_submitting = true;
+            cx.notify();
+
+            cx.spawn(async move |this, cx| {
+                // TODO: Implement API call to submit comment
+
+                this.update(cx, |panel, cx| {
+                    panel.comment_draft.clear();
+                    panel.is_submitting = false;
+                    panel.load_details(cx);
+                })?;
+
+                Ok::<(), anyhow::Error>(())
+            })
+            .detach_and_log_err(cx);
+        }
+    }
+
+    fn approve_pull_request(&mut self, _: &ApprovePullRequest, cx: &mut Context<Self>) {
+        if let Some(pr) = &self.pull_request {
+            let pr_number = pr.number;
+            let manager = self.manager.clone();
+            let review_comment = self.review_comment_draft.clone();
+
+            self.is_submitting = true;
+            cx.notify();
+
+            cx.spawn(async move |this, cx| {
+                // TODO: Implement API call to approve PR
+
+                this.update(cx, |panel, cx| {
+                    panel.review_comment_draft.clear();
+                    panel.show_review_form = false;
+                    panel.is_submitting = false;
+                    panel.load_details(cx);
+                })?;
+
+                Ok::<(), anyhow::Error>(())
+            })
+            .detach_and_log_err(cx);
+        }
+    }
+
+    fn merge_pull_request(&mut self, _: &MergePullRequest, cx: &mut Context<Self>) {
+        if let Some(pr) = &self.pull_request {
+            if !pr.mergeable.unwrap_or(false) {
+                return;
+            }
+
+            let pr_number = pr.number;
+            let manager = self.manager.clone();
+
+            self.is_submitting = true;
+            cx.notify();
+
+            cx.spawn(async move |this, cx| {
+                // TODO: Implement API call to merge PR
+
+                this.update(cx, |panel, cx| {
+                    panel.is_submitting = false;
+                    panel.load_details(cx);
+                })?;
+
+                Ok::<(), anyhow::Error>(())
+            })
+            .detach_and_log_err(cx);
+        }
+    }
+
+    fn render_pr_header(&self, pr: &PullRequest, cx: &mut Context<Self>) -> impl IntoElement {
+        let state_badge = match pr.state {
+            PullRequestState::Open => {
+                if pr.draft {
+                    h_flex()
+                        .gap_1()
+                        .child(Icon::new(IconName::PullRequest).size(IconSize::Small))
+                        .child(Label::new("Draft").size(LabelSize::Small))
+                        .px_2()
+                        .py_1()
+                        .rounded_md()
+                        .bg(Color::Modified.color(cx))
+                } else {
+                    h_flex()
+                        .gap_1()
+                        .child(Icon::new(IconName::PullRequest).size(IconSize::Small))
+                        .child(Label::new("Open").size(LabelSize::Small))
+                        .px_2()
+                        .py_1()
+                        .rounded_md()
+                        .bg(Color::Success.color(cx))
+                }
+            }
+            PullRequestState::Closed => h_flex()
+                .gap_1()
+                .child(Icon::new(IconName::Close).size(IconSize::Small))
+                .child(Label::new("Closed").size(LabelSize::Small))
+                .px_2()
+                .py_1()
+                .rounded_md()
+                .bg(Color::Error.color(cx)),
+            PullRequestState::Merged => h_flex()
+                .gap_1()
+                .child(Icon::new(IconName::GitBranch).size(IconSize::Small))
+                .child(Label::new("Merged").size(LabelSize::Small))
+                .px_2()
+                .py_1()
+                .rounded_md()
+                .bg(Color::Accent.color(cx)),
+        };
+
+        v_flex()
+            .gap_2()
+            .p_4()
+            .border_b_1()
+            .border_color(cx.theme().colors().border)
+            .child(
+                h_flex()
+                    .gap_2()
+                    .child(state_badge)
+                    .child(Label::new(format!("#{}", pr.number)).color(Color::Muted)),
+            )
+            .child(Label::new(SharedString::from(pr.title.clone())).size(LabelSize::Large))
+            .child(
+                h_flex()
+                    .gap_1()
+                    .child(Avatar::new(pr.user.avatar_url.to_string()).size(rems(1.0)))
+                    .child(
+                        Label::new(SharedString::from(pr.user.login.clone()))
+                            .size(LabelSize::Small),
+                    )
+                    .child(
+                        Label::new("wants to merge")
+                            .size(LabelSize::Small)
+                            .color(Color::Muted),
+                    )
+                    .child(
+                        Label::new(SharedString::from(format!(
+                            "{} commits into {}",
+                            pr.commits, pr.base.ref_name
+                        )))
+                        .size(LabelSize::Small),
+                    ),
+            )
+    }
+
+    fn render_pr_stats(&self, pr: &PullRequest, cx: &mut Context<Self>) -> impl IntoElement {
+        h_flex()
+            .gap_4()
+            .p_2()
+            .border_b_1()
+            .border_color(cx.theme().colors().border)
+            .child(
+                h_flex()
+                    .gap_1()
+                    .child(
+                        Icon::new(IconName::Plus)
+                            .size(IconSize::Small)
+                            .color(Color::Success),
+                    )
+                    .child(Label::new(format!("+{}", pr.additions)).size(LabelSize::Small)),
+            )
+            .child(
+                h_flex()
+                    .gap_1()
+                    .child(
+                        Icon::new(IconName::Trash)
+                            .size(IconSize::Small)
+                            .color(Color::Error),
+                    )
+                    .child(Label::new(format!("-{}", pr.deletions)).size(LabelSize::Small)),
+            )
+            .child(
+                h_flex()
+                    .gap_1()
+                    .child(Icon::new(IconName::File).size(IconSize::Small))
+                    .child(
+                        Label::new(format!("{} files", pr.changed_files)).size(LabelSize::Small),
+                    ),
+            )
+            .child(
+                h_flex()
+                    .gap_1()
+                    .child(Icon::new(IconName::Circle).size(IconSize::Small))
+                    .child(Label::new(format!("{} commits", pr.commits)).size(LabelSize::Small)),
+            )
+    }
+
+    fn render_pr_description(&self, pr: &PullRequest, cx: &mut Context<Self>) -> impl IntoElement {
+        v_flex()
+            .gap_2()
+            .p_4()
+            .child(Label::new("Description").size(LabelSize::Default))
+            .child(
+                div()
+                    .p_2()
+                    .rounded_md()
+                    .bg(cx.theme().colors().element_background)
+                    .child(
+                        // TODO: Render markdown properly
+                        Label::new(SharedString::from(pr.body.clone()))
+                            .size(LabelSize::Small)
+                            .color(Color::Default),
+                    ),
+            )
+    }
+
+    fn render_action_buttons(&self, pr: &PullRequest, cx: &mut Context<Self>) -> impl IntoElement {
+        let can_merge = pr.mergeable.unwrap_or(false) && pr.state == PullRequestState::Open;
+
+        h_flex()
+            .gap_2()
+            .p_4()
+            .border_b_1()
+            .border_color(cx.theme().colors().border)
+            .when(pr.state == PullRequestState::Open, |this| {
+                this.child(
+                    Button::new("approve", "Approve")
+                        .style(ButtonStyle::Filled)
+                        .on_click(cx.listener(|this, _, _window, cx| {
+                            this.approve_pull_request(&ApprovePullRequest, cx);
+                        })),
+                )
+                .child(
+                    Button::new("request-changes", "Request Changes")
+                        .style(ButtonStyle::Subtle)
+                        .on_click(cx.listener(|this, _, _window, cx| {
+                            this.show_review_form = true;
+                            cx.notify();
+                        })),
+                )
+            })
+            .when(can_merge, |this| {
+                this.child(
+                    Button::new("merge", "Merge Pull Request")
+                        .style(ButtonStyle::Filled)
+                        .color(Color::Success)
+                        .on_click(cx.listener(|this, _, _window, cx| {
+                            this.merge_pull_request(&MergePullRequest, cx);
+                        }))
+                        .when(self.is_submitting, |btn| btn.disabled(true)),
+                )
+            })
+            .child(
+                IconButton::new("open-browser", IconName::ArrowUpRight)
+                    .tooltip(ui::Tooltip::text("Open in Browser"))
+                    .on_click(cx.listener(|this, _, _window, cx| {
+                        if let Some(pr) = &this.pull_request {
+                            cx.open_url(&pr.html_url);
+                        }
+                    })),
+            )
+            .child(
+                IconButton::new("refresh", IconName::Rerun)
+                    .tooltip(ui::Tooltip::text("Refresh"))
+                    .on_click(cx.listener(|this, _, _window, cx| {
+                        this.load_details(cx);
+                    })),
+            )
+    }
+
+    fn render_comments(&self, cx: &mut Context<Self>) -> impl IntoElement {
+        v_flex()
+            .gap_2()
+            .p_4()
+            .child(
+                h_flex()
+                    .justify_between()
+                    .child(Label::new("Comments").size(LabelSize::Default))
+                    .child(
+                        Label::new(format!("{} comments", self.comments.len()))
+                            .size(LabelSize::Small)
+                            .color(Color::Muted),
+                    ),
+            )
+            .children(
+                self.comments
+                    .iter()
+                    .map(|comment| self.render_comment(comment, cx)),
+            )
+            .child(self.render_comment_form(cx))
+    }
+
+    fn render_comment(
+        &self,
+        comment: &PullRequestComment,
+        cx: &mut Context<Self>,
+    ) -> impl IntoElement {
+        h_flex()
+            .gap_2()
+            .p_2()
+            .rounded_md()
+            .bg(cx.theme().colors().element_background)
+            .child(Avatar::new(comment.user.avatar_url.to_string()).size(rems(1.5)))
+            .child(
+                v_flex()
+                    .gap_1()
+                    .flex_1()
+                    .child(
+                        h_flex()
+                            .gap_2()
+                            .child(
+                                Label::new(SharedString::from(comment.user.login.clone()))
+                                    .size(LabelSize::Small),
+                            )
+                            .child(
+                                Label::new(format_time_ago(comment.created_at))
+                                    .size(LabelSize::Small)
+                                    .color(Color::Muted),
+                            ),
+                    )
+                    .child(
+                        Label::new(SharedString::from(comment.body.clone())).size(LabelSize::Small),
+                    ),
+            )
+    }
+
+    fn render_comment_form(&self, cx: &mut Context<Self>) -> impl IntoElement {
+        v_flex()
+            .gap_2()
+            .child(
+                div()
+                    .h(px(100.0))
+                    .w_full()
+                    .rounded_md()
+                    .border_1()
+                    .border_color(cx.theme().colors().border)
+                    .p_2()
+                    .bg(cx.theme().colors().editor_background)
+                    .child(
+                        Label::new(if self.comment_draft.is_empty() {
+                            SharedString::from("Leave a comment...")
+                        } else {
+                            SharedString::from(self.comment_draft.clone())
+                        })
+                        .size(LabelSize::Small)
+                        .color(if self.comment_draft.is_empty() {
+                            Color::Muted
+                        } else {
+                            Color::Default
+                        }),
+                    ),
+            )
+            .child(
+                h_flex().justify_end().child(
+                    Button::new("submit-comment", "Comment")
+                        .style(ButtonStyle::Filled)
+                        .disabled(self.comment_draft.trim().is_empty() || self.is_submitting)
+                        .on_click(cx.listener(|this, _, _window, cx| {
+                            this.submit_comment(&SubmitComment, cx);
+                        })),
+                ),
+            )
+    }
+}
+
+impl Render for PullRequestDetailPanel {
+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
+        if let Some(pr) = &self.pull_request {
+            v_flex()
+                .size_full()
+                .child(self.render_pr_header(pr, cx))
+                .child(self.render_action_buttons(pr, cx))
+                .child(self.render_pr_stats(pr, cx))
+                .child(
+                    div()
+                        .flex_1()
+                        .overflow_y_scroll()
+                        .track_focus(&self.focus_handle)
+                        .child(self.render_pr_description(pr, cx))
+                        .child(self.render_comments(cx)),
+                )
+        } else {
+            v_flex()
+                .size_full()
+                .items_center()
+                .justify_center()
+                .child(Label::new("No pull request selected").color(Color::Muted))
+        }
+    }
+}
+
+impl Focusable for PullRequestDetailPanel {
+    fn focus_handle(&self, _cx: &App) -> FocusHandle {
+        self.focus_handle.clone()
+    }
+}
+
+impl EventEmitter<()> for PullRequestDetailPanel {}
+
+fn format_time_ago(time: DateTime<Utc>) -> String {
+    let now = Utc::now();
+    let duration = now.signed_duration_since(time);
+
+    if duration.num_days() > 365 {
+        format!("{} years ago", duration.num_days() / 365)
+    } else if duration.num_days() > 30 {
+        format!("{} months ago", duration.num_days() / 30)
+    } else if duration.num_days() > 0 {
+        format!("{} days ago", duration.num_days())
+    } else if duration.num_hours() > 0 {
+        format!("{} hours ago", duration.num_hours())
+    } else if duration.num_minutes() > 0 {
+        format!("{} minutes ago", duration.num_minutes())
+    } else {
+        "just now".to_string()
+    }
+}
diff --git a/crates/pull_requests_ui/src/pr_detail_view.rs b/crates/pull_requests_ui/src/pr_detail_view.rs
new file mode 100644
index 0000000000..2e5f89b6a0
--- /dev/null
+++ b/crates/pull_requests_ui/src/pr_detail_view.rs
@@ -0,0 +1,1316 @@
+use anyhow::Result;
+use chrono;
+use gpui::{
+    actions, div, App, ClipboardItem, Context, Corner, DismissEvent, Entity, EventEmitter, 
+    FocusHandle, Focusable, InteractiveElement, IntoElement, MouseButton, MouseDownEvent,
+    ParentElement, Pixels, Point, Render, ScrollHandle, SharedString, Styled, Subscription, Window, KeyDownEvent,
+    anchored, deferred, px,
+};
+use pull_requests::{PullRequest, PullRequestState, PullRequestComment, PullRequestReview, GithubAuth, GithubPrClient, PullRequestApi, models::User};
+use git::ParsedGitRemote;
+use gpui::http_client::HttpClient;
+use project::Project;
+use ui::{prelude::*, v_flex, h_flex, ButtonStyle, ButtonLike, Icon, IconName, IconSize, Color, ContextMenu, StyledTypography, Label};
+use theme::observe_buffer_font_size_adjustment;
+use workspace::item::Item;
+use zed_actions::{DecreaseBufferFontSize, IncreaseBufferFontSize, ResetBufferFontSize};
+
+actions!(pr_detail, [OpenInBrowser, CopyTitle, CopyDescription, CopyAll, SelectAll, CopyComment]);
+
+#[derive(Debug, Clone)]
+enum ContextMenuTarget {
+    Title,
+    Description,
+    Comment(String), // Store the comment text
+    General,
+}
+
+pub fn init(cx: &mut App) {
+    cx.observe_new(|_workspace: &mut workspace::Workspace, _window, _cx| {}).detach();
+}
+
+pub struct PullRequestDetailView {
+    pub pr: PullRequest,
+    focus_handle: FocusHandle,
+    scroll_handle: ScrollHandle,
+    _font_size_subscription: gpui::Subscription,
+    context_menu: Option<(Entity<ContextMenu>, Point<Pixels>, Subscription)>,
+    comments: Vec<PullRequestComment>,
+    reviews: Vec<PullRequestReview>,
+    loading_comments: bool,
+    api_client: std::sync::Arc<dyn PullRequestApi>,
+    remote: ParsedGitRemote,
+    // Text selection state
+    selection_start: Option<usize>,
+    selection_end: Option<usize>,
+    is_selecting: bool,
+    selected_text: Option<String>,
+    // Context menu state
+    context_menu_target: Option<ContextMenuTarget>,
+}
+
+impl PullRequestDetailView {
+    /// Creates a new PullRequestDetailView with proper authentication using project info
+    pub fn new_with_project(
+        pr: PullRequest, 
+        project: &Entity<Project>,
+        cx: &mut Context<Self>
+    ) -> anyhow::Result<Self> {
+        let http_client = project.read(cx).client().http_client();
+        
+        // Get authentication token from GithubAuth
+        let token = GithubAuth::global(cx).token().map(|t| t.to_string());
+        let api_client = std::sync::Arc::new(GithubPrClient::new_with_auth(http_client, token));
+        
+        // Extract remote info from the PR's HTML URL
+        let remote = Self::parse_remote_from_pr_url(&pr.html_url.to_string())?;
+        
+        Ok(Self::new(pr, api_client, remote, cx))
+    }
+
+    /// Creates a new PullRequestDetailView with proper authentication
+    pub fn new_with_authentication(
+        pr: PullRequest, 
+        http_client: std::sync::Arc<dyn HttpClient>,
+        remote: ParsedGitRemote,
+        cx: &mut Context<Self>
+    ) -> Self {
+        // Get authentication token from GithubAuth
+        let token = GithubAuth::global(cx).token().map(|t| t.to_string());
+        let api_client = std::sync::Arc::new(GithubPrClient::new_with_auth(http_client, token));
+        
+        Self::new(pr, api_client, remote, cx)
+    }
+
+    /// Parse remote info from a GitHub PR URL
+    fn parse_remote_from_pr_url(url: &str) -> anyhow::Result<ParsedGitRemote> {
+        // Expected format: https://github.com/owner/repo/pull/123
+        if let Some(start) = url.find("github.com/") {
+            let path_start = start + "github.com/".len();
+            let path = &url[path_start..];
+            let parts: Vec<&str> = path.split('/').collect();
+            if parts.len() >= 2 {
+                return Ok(ParsedGitRemote {
+                    owner: parts[0].into(),
+                    repo: parts[1].into(),
+                });
+            }
+        }
+        anyhow::bail!("Could not parse GitHub remote from PR URL: {}", url)
+    }
+
+    fn render_selectable_text(&self, cx: &Context<Self>) -> impl IntoElement {
+        let description = self.pr.body.clone().unwrap_or_else(|| "No description provided".to_string());
+        let theme = cx.theme();
+        
+        // If we have a selection, render it with highlighting
+        if let (Some(start), Some(end)) = (self.selection_start, self.selection_end) {
+            let actual_start = start.min(end);
+            let actual_end = start.max(end);
+            
+            if actual_start < description.len() && actual_end <= description.len() && actual_start != actual_end {
+                // Create a container with the description split into three parts:
+                // before selection, selected text, after selection
+                return div()
+                    .flex()
+                    .flex_wrap()
+                    .children([
+                        // Text before selection
+                        if actual_start > 0 {
+                            Some(div().text_buffer(cx).child(SharedString::from(description[..actual_start].to_string())))
+                        } else {
+                            None
+                        },
+                        // Selected text with highlight background
+                        Some(
+                            div()
+                                    .bg(theme.colors().editor_active_line_background)
+                                .child(SharedString::from(description[actual_start..actual_end].to_string()))
+                        ),
+                        // Text after selection
+                        if actual_end < description.len() {
+                            Some(div().text_buffer(cx).child(SharedString::from(description[actual_end..].to_string())))
+                        } else {
+                            None
+                        },
+                    ].into_iter().flatten());
+            }
+        }
+        
+        // No selection, just render the plain text
+        div().text_buffer(cx).child(SharedString::from(description))
+    }
+    
+    pub fn new(pr: PullRequest, api_client: std::sync::Arc<dyn PullRequestApi>, remote: ParsedGitRemote, cx: &mut Context<Self>) -> Self {
+        let focus_handle = cx.focus_handle();
+        let scroll_handle = ScrollHandle::new();
+        
+        // Subscribe to font size changes to trigger re-rendering
+        let font_size_subscription = observe_buffer_font_size_adjustment(cx, |_this, cx| {
+            cx.notify();
+        });
+        
+        let mut view = Self {
+            pr,
+            focus_handle,
+            scroll_handle,
+            _font_size_subscription: font_size_subscription,
+            context_menu: None,
+            comments: Vec::new(),
+            reviews: Vec::new(),
+            loading_comments: true,
+            api_client,
+            remote,
+            selection_start: None,
+            selection_end: None,
+            is_selecting: false,
+            selected_text: None,
+            context_menu_target: None,
+        };
+        
+        // Fetch comments asynchronously
+        view.fetch_comments(cx);
+        
+        view
+    }
+
+    fn increase_font_size(
+        &mut self,
+        action: &IncreaseBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        if !action.persist {
+            theme::adjust_buffer_font_size(cx, |size| {
+                let new_size = size + gpui::px(1.0);
+                new_size
+            });
+            cx.notify();
+        }
+    }
+
+    fn decrease_font_size(
+        &mut self,
+        action: &DecreaseBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        if !action.persist {
+            theme::adjust_buffer_font_size(cx, |size| {
+                size - gpui::px(1.0)
+            });
+            cx.notify();
+        }
+    }
+
+    fn reset_font_size(
+        &mut self,
+        action: &ResetBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        if !action.persist {
+            theme::reset_buffer_font_size(cx);
+            cx.notify();
+        }
+    }
+    
+    fn fetch_comments(&mut self, cx: &mut Context<Self>) {
+        let pr_number = self.pr.number;
+        let api_client = self.api_client.clone();
+        let remote = self.remote.clone();
+        
+        self.loading_comments = true;
+        cx.notify();
+        
+        cx.spawn(async move |this, cx| {
+            log::info!("Fetching comments for PR #{} from {}/{}", pr_number, remote.owner, remote.repo);
+            match api_client.list_pull_request_comments(&remote, pr_number).await {
+                Ok(comments) => {
+                    log::info!("Received {} comments from API for PR #{}", comments.len(), pr_number);
+                    this.update(cx, |view, cx| {
+                        // If we got comments, use them. Otherwise create mock comments for testing
+                        if !comments.is_empty() {
+                            log::info!("Using {} real comments from API", comments.len());
+                            view.comments = comments;
+                        } else {
+                            log::info!("No comments from API, using mock comments for testing");
+                            view.comments = vec![
+                                PullRequestComment {
+                                    id: 1,
+                                    user: view.pr.user.clone(),
+                                    body: Some("This looks great! The implementation is clean and well-structured.".to_string()),
+                                    created_at: chrono::Utc::now() - chrono::Duration::hours(2),
+                                    updated_at: chrono::Utc::now() - chrono::Duration::hours(2),
+                                    reactions: Default::default(),
+                                },
+                                PullRequestComment {
+                                    id: 2,
+                                    user: pull_requests::models::User {
+                                        login: "reviewer".to_string(),
+                                        id: 999,
+                                        avatar_url: view.pr.user.avatar_url.clone(),
+                                        html_url: None,
+                                    },
+                                    body: Some("Could you add some tests for this feature?".to_string()),
+                                    created_at: chrono::Utc::now() - chrono::Duration::hours(1),
+                                    updated_at: chrono::Utc::now() - chrono::Duration::hours(1),
+                                    reactions: Default::default(),
+                                },
+                                PullRequestComment {
+                                    id: 3,
+                                    user: view.pr.user.clone(),
+                                    body: Some("Sure! I'll add tests in the next commit.".to_string()),
+                                    created_at: chrono::Utc::now() - chrono::Duration::minutes(30),
+                                    updated_at: chrono::Utc::now() - chrono::Duration::minutes(30),
+                                    reactions: Default::default(),
+                                },
+                            ];
+                        }
+                        view.loading_comments = false;
+                        cx.notify();
+                    })?;
+                }
+                Err(e) => {
+                    log::error!("Failed to fetch PR comments: {}", e);
+                    this.update(cx, |view, cx| {
+                        view.loading_comments = false;
+                        // Show mock comments even on error for now
+                        view.comments = vec![
+                            PullRequestComment {
+                                id: 1,
+                                user: view.pr.user.clone(),
+                                body: Some(format!("Comments API failed: {}. Showing demo comments.", e)),
+                                created_at: chrono::Utc::now(),
+                                updated_at: chrono::Utc::now(),
+                                reactions: Default::default(),
+                            },
+                        ];
+                        cx.notify();
+                    })?;
+                }
+            }
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach();
+    }
+
+    pub fn update_pr(&mut self, pr: PullRequest, cx: &mut Context<Self>) {
+        self.dismiss_context_menu(cx);
+        self.pr = pr;
+        // Refetch comments when PR is updated
+        self.fetch_comments(cx);
+        cx.notify();
+    }
+
+    fn deploy_context_menu(&mut self, position: Point<Pixels>, window: &mut Window, cx: &mut Context<Self>) {
+        self.dismiss_context_menu(cx);
+        
+        let target = self.context_menu_target.clone();
+        let focus_handle = self.focus_handle.clone();
+        let context_menu = ContextMenu::build(window, cx, move |menu, _, _| {
+            let menu_with_context = menu.context(focus_handle.clone());
+            match target.as_ref() {
+                Some(ContextMenuTarget::Title) => {
+                    menu_with_context
+                        .action("Copy Title", Box::new(CopyTitle))
+                        .separator()
+                        .action("Copy All", Box::new(CopyAll))
+                }
+                Some(ContextMenuTarget::Description) => {
+                    menu_with_context
+                        .action("Copy Description", Box::new(CopyDescription))
+                        .separator()
+                        .action("Copy All", Box::new(CopyAll))
+                }
+                Some(ContextMenuTarget::Comment(_)) => {
+                    menu_with_context
+                        .action("Copy Comment", Box::new(CopyComment))
+                        .separator()
+                        .action("Copy All Comments", Box::new(CopyAll))
+                }
+                _ => {
+                    menu_with_context
+                        .action("Copy Title", Box::new(CopyTitle))
+                        .action("Copy Description", Box::new(CopyDescription))
+                        .separator()
+                        .action("Copy All", Box::new(CopyAll))
+                        .action("Select All", Box::new(SelectAll))
+                }
+            }
+        });
+        
+        // Focus the context menu
+        window.focus(&context_menu.focus_handle(cx));
+        
+        // Subscribe to dismiss events with proper focus return
+        let subscription = cx.subscribe_in(&context_menu, window, |this, _, _: &DismissEvent, window, cx| {
+            if this.context_menu.as_ref().is_some_and(|(menu, _, _)| {
+                menu.focus_handle(cx).contains_focused(window, cx)
+            }) {
+                window.focus(&this.focus_handle(cx));
+            }
+            this.context_menu.take();
+            cx.notify();
+        });
+        
+        self.context_menu = Some((context_menu, position, subscription));
+        cx.notify();
+    }
+    
+    fn dismiss_context_menu(&mut self, cx: &mut Context<Self>) {
+        if self.context_menu.take().is_some() {
+            cx.notify();
+        }
+    }
+
+    fn copy_title(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        let text = format!("#{} {}", self.pr.number, self.pr.title);
+        cx.write_to_clipboard(ClipboardItem::new_string(text));
+    }
+
+    fn copy_description(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        // If there's selected text, copy that. Otherwise copy full description
+        let text = if let Some(selected) = &self.selected_text {
+            selected.clone()
+        } else {
+            self.pr.body.clone().unwrap_or_else(|| "No description provided".to_string())
+        };
+        cx.write_to_clipboard(ClipboardItem::new_string(text));
+    }
+    
+    fn copy_comment(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        if let Some(ContextMenuTarget::Comment(text)) = &self.context_menu_target {
+            cx.write_to_clipboard(ClipboardItem::new_string(text.clone()));
+        }
+    }
+    
+    fn start_selection(&mut self, char_index: usize) {
+        self.selection_start = Some(char_index);
+        self.selection_end = Some(char_index);
+        self.is_selecting = true;
+    }
+    
+    fn update_selection(&mut self, char_index: usize, cx: &mut Context<Self>) {
+        if self.is_selecting {
+            self.selection_end = Some(char_index);
+            self.update_selected_text();
+            cx.notify();
+        }
+    }
+    
+    fn end_selection(&mut self, cx: &mut Context<Self>) {
+        self.is_selecting = false;
+        self.update_selected_text();
+        cx.notify();
+    }
+    
+    fn update_selected_text(&mut self) {
+        if let (Some(start), Some(end)) = (self.selection_start, self.selection_end) {
+            if let Some(body) = &self.pr.body {
+                let actual_start = start.min(end);
+                let actual_end = start.max(end);
+                if actual_start < body.len() && actual_end <= body.len() && actual_start != actual_end {
+                    self.selected_text = Some(body[actual_start..actual_end].to_string());
+                } else {
+                    self.selected_text = None;
+                }
+            }
+        } else {
+            self.selected_text = None;
+        }
+    }
+    
+    fn clear_selection(&mut self, cx: &mut Context<Self>) {
+        self.selection_start = None;
+        self.selection_end = None;
+        self.is_selecting = false;
+        self.selected_text = None;
+        cx.notify();
+    }
+    
+    fn select_all_description(&mut self, cx: &mut Context<Self>) {
+        if let Some(body) = &self.pr.body {
+            self.selection_start = Some(0);
+            self.selection_end = Some(body.len());
+            self.selected_text = Some(body.clone());
+            cx.notify();
+        }
+    }
+
+    fn copy_all(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        // Check if we're in comment context
+        if matches!(self.context_menu_target, Some(ContextMenuTarget::Comment(_))) {
+            // Copy all comments
+            let mut text = String::new();
+            for comment in &self.comments {
+                text.push_str(&format!(
+                    "{} ({}): {}\n\n",
+                    comment.user.login,
+                    self.format_date(&comment.created_at),
+                    comment.body.as_deref().unwrap_or("")
+                ));
+            }
+            cx.write_to_clipboard(ClipboardItem::new_string(text));
+        } else {
+            // Copy PR details
+            let text = format!(
+                "#{} {}\n\n{}\n\nURL: {}",
+                self.pr.number,
+                self.pr.title,
+                self.pr.body.clone().unwrap_or_else(|| "No description provided".to_string()),
+                self.pr.html_url
+            );
+            cx.write_to_clipboard(ClipboardItem::new_string(text));
+        }
+    }
+
+    fn select_all(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        let text = format!(
+            "#{} {}\n\n{}\n\nURL: {}",
+            self.pr.number,
+            self.pr.title,
+            self.pr.body.clone().unwrap_or_else(|| "No description provided".to_string()),
+            self.pr.html_url
+        );
+        cx.write_to_clipboard(ClipboardItem::new_string(text));
+        cx.notify();
+    }
+}
+
+impl Render for PullRequestDetailView {
+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
+        let theme = cx.theme();
+        
+        div()
+            .size_full()
+            .child(
+                div()
+            .id("pr-detail-scroll")
+            .size_full()
+            .overflow_y_scroll()
+            .track_focus(&self.focus_handle)
+            .track_scroll(&self.scroll_handle)
+            .text_buffer(cx)  // Enable zoom for all text content
+            .on_mouse_down(
+                MouseButton::Right,
+                cx.listener(|this, event: &MouseDownEvent, window, cx| {
+                    this.deploy_context_menu(event.position, window, cx);
+                    cx.stop_propagation();
+                }),
+            )
+            .on_action(cx.listener(|this, action: &IncreaseBufferFontSize, _window, cx| {
+                this.increase_font_size(action, _window, cx);
+            }))
+            .on_action(cx.listener(|this, action: &DecreaseBufferFontSize, _window, cx| {
+                this.decrease_font_size(action, _window, cx);
+            }))
+            .on_action(cx.listener(|this, action: &ResetBufferFontSize, _window, cx| {
+                this.reset_font_size(action, _window, cx);
+            }))
+            .on_action(cx.listener(|this, _: &CopyTitle, window, cx| {
+                this.copy_title(window, cx);
+            }))
+            .on_action(cx.listener(|this, _: &CopyDescription, window, cx| {
+                this.copy_description(window, cx);
+            }))
+            .on_action(cx.listener(|this, _: &CopyAll, window, cx| {
+                this.copy_all(window, cx);
+            }))
+            .on_action(cx.listener(|this, _: &SelectAll, window, cx| {
+                this.select_all(window, cx);
+            }))
+            .on_action(cx.listener(|this, _: &CopyComment, window, cx| {
+                this.copy_comment(window, cx);
+            }))
+            .child(
+                v_flex()
+                    .child(
+                        // Header
+                        h_flex()
+                            .p_4()
+                            .gap_4()
+                            .border_b_1()
+                            .border_color(theme.colors().border)
+                            .child(
+                                v_flex()
+                                    .flex_1()
+                                    .gap_1()
+                                    .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(
+                                        // Title with zoom support
+                                        div()
+                                            .on_mouse_down(
+                                                MouseButton::Right,
+                                                cx.listener(|this, event: &MouseDownEvent, window, cx| {
+                                                    this.context_menu_target = Some(ContextMenuTarget::Title);
+                                                    this.deploy_context_menu(event.position, window, cx);
+                                                    cx.stop_propagation();
+                                                }),
+                                            )
+                                            .child(SharedString::from(format!(
+                                                "#{} {}",
+                                                self.pr.number, self.pr.title
+                                            ))),
+                                    )
+                                    .child(self.render_state_badge(cx)),
+                            )
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child(SharedString::from(format!(
+                                                "opened by {}",
+                                                self.pr.user.login
+                                            )))
+                                    )
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child("•")
+                                    )
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child(SharedString::from(format!(
+                                                "created {}",
+                                                self.format_date(&self.pr.created_at)
+                                            )))
+                                    )
+                                    .when(self.pr.updated_at != self.pr.created_at, |this| {
+                                        this.child(
+                                                div()
+                                                                                    .text_color(cx.theme().colors().text_muted)
+                                                    .child("•")
+                                            )
+                                            .child(
+                                                div()
+                                                                                    .text_color(cx.theme().colors().text_muted)
+                                                    .child(SharedString::from(format!(
+                                                        "updated {}",
+                                                        self.format_date(&self.pr.updated_at)
+                                                    )))
+                                            )
+                                    }),
+                            ),
+                    )
+                    .child(
+                        ButtonLike::new("open-in-browser")
+                            .style(ButtonStyle::Subtle)
+                            .child(h_flex().gap_1()
+                                .child(Icon::new(IconName::ArrowUpRight).size(IconSize::Small))
+                                .child(Label::new("Open in Browser").buffer_font(cx))
+                            )
+                            .on_click(cx.listener(|this, _, _window, cx| {
+                                cx.open_url(this.pr.html_url.as_str());
+                            })),
+                    )
+                            )
+                    )
+                    .child(
+                        // Body
+                v_flex()
+                    .flex_1()
+                    .p_4()
+                    .pb_8()  // Add extra bottom padding
+                    .gap_4()
+                    .child(
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("Description")
+                            )
+                            .child(
+                                div()
+                                    .p_3()
+                                    .rounded_md()
+                                    .bg(theme.colors().element_background)
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .on_mouse_down(
+                                        MouseButton::Right,
+                                        cx.listener(|this, event: &MouseDownEvent, window, cx| {
+                                            this.context_menu_target = Some(ContextMenuTarget::Description);
+                                            this.deploy_context_menu(event.position, window, cx);
+                                            cx.stop_propagation();
+                                        }),
+                                    )
+                                    .child(
+                                        // Selectable description with text highlighting
+                                        div()
+                                                            .cursor_text()
+                                            .on_mouse_down(
+                                                MouseButton::Left,
+                                                cx.listener(|this, _event: &MouseDownEvent, _window, cx| {
+                                                    // For now, clear selection on click
+                                                    // TODO: implement proper char index calculation from mouse position
+                                                    this.clear_selection(cx);
+                                                }),
+                                            )
+                                            .on_key_down(cx.listener(|this, event: &KeyDownEvent, _window, cx| {
+                                                // Handle Cmd+A for select all
+                                                if event.keystroke.key == "a" && event.keystroke.modifiers.platform {
+                                                    this.select_all_description(cx);
+                                                    cx.stop_propagation();
+                                                }
+                                                // Handle Cmd+C for copy
+                                                if event.keystroke.key == "c" && event.keystroke.modifiers.platform {
+                                                    if this.selected_text.is_some() {
+                                                        this.copy_description(_window, cx);
+                                                        cx.stop_propagation();
+                                                    }
+                                                }
+                                            }))
+                                            .child(
+                                                self.render_selectable_text(cx)
+                                            ),
+                                    ),
+                            ),
+                    )
+                    .child(
+                        // Comments section
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .items_center()
+                                    .child(
+                                        div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                            .child("Comments")
+                                    )
+                                    .child(
+                                        div()
+                                            .px_2()
+                                            .py_px()
+                                            .rounded_md()
+                                            .bg(theme.colors().element_background)
+                                            .child(
+                                                div()
+                                                    .text_color(cx.theme().colors().text_muted)
+                                                    .child(SharedString::from(format!(
+                                                        "{} total", 
+                                                        self.comments.len()
+                                                    )))
+                                            )
+                                    )
+                            )
+                            .child(
+                                if self.loading_comments {
+                                    div()
+                                        .p_3()
+                                        .rounded_md()
+                                        .bg(theme.colors().element_background)
+                                        .border_1()
+                                        .border_color(theme.colors().border)
+                                        .child(
+                                            div()
+                                                .text_color(cx.theme().colors().text_muted)
+                                                .child("Loading comments...")
+                                        )
+                                } else if self.comments.is_empty() {
+                                    div()
+                                        .p_3()
+                                        .rounded_md()
+                                        .bg(theme.colors().element_background)
+                                        .border_1()
+                                        .border_color(theme.colors().border)
+                                        .child(
+                                            div()
+                                                .text_color(cx.theme().colors().text_muted)
+                                                .child("No comments yet")
+                                        )
+                                } else {
+                                    v_flex()
+                                        .gap_2()
+                                        .children(self.comments.iter().map(|comment| {
+                                            let comment_text = comment.body.as_deref().unwrap_or("").to_string();
+                                            let comment_text_for_menu = comment_text.clone();
+                                            
+                                            div()
+                                                .mb_3()
+                                                .child(
+                                                    v_flex()
+                                                        .rounded_md()
+                                                        .border_1()
+                                                        .border_color(theme.colors().border)
+                                                        .overflow_hidden()
+                                                        .child(
+                                                            // Comment header with username and date
+                                                            div()
+                                                                .p_2()
+                                                                .bg(theme.colors().element_background)
+                                                                .border_b_1()
+                                                                .border_color(theme.colors().border)
+                                                                .child(
+                                                                    h_flex()
+                                                                        .gap_3()
+                                                                        .items_center()
+                                                                        .child(
+                                                                            div()
+                                                                                .text_color(cx.theme().colors().text)
+                                                                                .font_weight(gpui::FontWeight::SEMIBOLD)
+                                                                                .child(SharedString::from(comment.user.login.clone()))
+                                                                        )
+                                                                        .child(
+                                                                            div()
+                                                                                .text_color(cx.theme().colors().text_muted)
+                                                                                .child(SharedString::from(format!("• {}", self.format_date(&comment.created_at))))
+                                                                        )
+                                                                )
+                                                        )
+                                                        .child(
+                                                            // Comment body - separately selectable
+                                                            div()
+                                                                .p_3()
+                                                                .bg(theme.colors().editor_background)
+                                                                .cursor_text()
+                                                                .on_mouse_down(
+                                                                    MouseButton::Right,
+                                                                    cx.listener(move |this, event: &MouseDownEvent, window, cx| {
+                                                                        this.context_menu_target = Some(ContextMenuTarget::Comment(comment_text_for_menu.clone()));
+                                                                        this.deploy_context_menu(event.position, window, cx);
+                                                                        cx.stop_propagation();
+                                                                    }),
+                                                                )
+                                                                .child(
+                                                                    div()
+                                                                        .text_buffer(cx)
+                                                                        .child(SharedString::from(comment_text))
+                                                                )
+                                                        )
+                                                        .when(comment.reactions.total_count > 0, |this| {
+                                                            this.child(
+                                                                div()
+                                                                    .p_2()
+                                                                    .bg(theme.colors().element_background)
+                                                                    .border_t_1()
+                                                                    .border_color(theme.colors().border)
+                                                                    .child(
+                                                                        h_flex()
+                                                                            .gap_2()
+                                                                            .children([
+                                                                                (comment.reactions.plus_one > 0).then(|| 
+                                                                                    div()
+                                                                                        .px_2()
+                                                                                        .py_px()
+                                                                                        .rounded_md()
+                                                                                        .bg(theme.colors().element_hover)
+                                                                                        .child(SharedString::from(format!("👍 {}", comment.reactions.plus_one)))
+                                                                                ),
+                                                                                (comment.reactions.heart > 0).then(|| 
+                                                                                    div()
+                                                                                        .px_2()
+                                                                                        .py_px()
+                                                                                        .rounded_md()
+                                                                                        .bg(theme.colors().element_hover)
+                                                                                        .child(SharedString::from(format!("❤️ {}", comment.reactions.heart)))
+                                                                                ),
+                                                                                (comment.reactions.laugh > 0).then(|| 
+                                                                                    div()
+                                                                                        .px_2()
+                                                                                        .py_px()
+                                                                                        .rounded_md()
+                                                                                        .bg(theme.colors().element_hover)
+                                                                                        .child(SharedString::from(format!("😄 {}", comment.reactions.laugh)))
+                                                                                ),
+                                                                                (comment.reactions.hooray > 0).then(|| 
+                                                                                    div()
+                                                                                        .px_2()
+                                                                                        .py_px()
+                                                                                        .rounded_md()
+                                                                                        .bg(theme.colors().element_hover)
+                                                                                        .child(SharedString::from(format!("🎉 {}", comment.reactions.hooray)))
+                                                                                ),
+                                                                            ].into_iter().flatten())
+                                                                    )
+                                                            )
+                                                        })
+                                                )
+                                        }))
+                                }
+                            )
+                    )
+            )
+                    .child(
+                        // Branch information
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("Branches")
+                            )
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(
+                                        div()
+                                            .px_2()
+                                            .py_1()
+                                            .rounded_md()
+                                            .bg(theme.colors().element_background)
+                                            .child(
+                                                div()
+                                                                            .child(SharedString::from(format!("{}:{}", 
+                                                        self.pr.base.repo.as_ref().map(|r| r.owner.login.as_str()).unwrap_or("unknown"), 
+                                                        self.pr.base.ref_name)))
+                                            ),
+                                    )
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child("←")
+                                    )
+                                    .child(
+                                        div()
+                                            .px_2()
+                                            .py_1()
+                                            .rounded_md()
+                                            .bg(theme.colors().element_background)
+                                            .child(
+                                                div()
+                                                                            .child(SharedString::from(format!("{}:{}", 
+                                                        self.pr.head.repo.as_ref().map(|r| r.owner.login.as_str()).unwrap_or("unknown"),
+                                                        self.pr.head.ref_name)))
+                                            ),
+                                    ),
+                            ),
+                    )
+                    .child(
+                        // File changes section
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("File Changes")
+                            )
+                            .child(
+                                div()
+                                    .p_3()
+                                    .rounded_md()
+                                    .bg(theme.colors().element_background)
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .child(
+                                        h_flex()
+                                            .gap_6()
+                                            .child(
+                                                v_flex()
+                                                    .gap_1()
+                                                    .child(
+                                                        h_flex()
+                                                            .gap_1()
+                                                            .items_center()
+                                                            .child(Icon::new(IconName::File).size(IconSize::Small).color(Color::Muted))
+                                                            .child(
+                                                                div()
+                                                                                                            .child(SharedString::from(format!("{}", self.pr.changed_files)))
+                                                            )
+                                                    )
+                                                    .child(
+                                                        div()
+                                                                                            .text_color(cx.theme().colors().text_muted)
+                                                            .child("Files")
+                                                    ),
+                                            )
+                                            .child(
+                                                v_flex()
+                                                    .gap_1()
+                                                    .child(
+                                                        h_flex()
+                                                            .gap_1()
+                                                            .items_center()
+                                                            .child(Icon::new(IconName::Plus).size(IconSize::Small).color(Color::Success))
+                                                            .child(
+                                                                div()
+                                                                                                            .text_color(cx.theme().status().success)
+                                                                    .child(SharedString::from(format!("{}", self.pr.additions)))
+                                                            )
+                                                    )
+                                                    .child(
+                                                        div()
+                                                                                            .text_color(cx.theme().colors().text_muted)
+                                                            .child("Added")
+                                                    ),
+                                            )
+                                            .child(
+                                                v_flex()
+                                                    .gap_1()
+                                                    .child(
+                                                        h_flex()
+                                                            .gap_1()
+                                                            .items_center()
+                                                            .child(Icon::new(IconName::Dash).size(IconSize::Small).color(Color::Error))
+                                                            .child(
+                                                                div()
+                                                                                                            .text_color(cx.theme().status().error)
+                                                                    .child(SharedString::from(format!("{}", self.pr.deletions)))
+                                                            )
+                                                    )
+                                                    .child(
+                                                        div()
+                                                                                            .text_color(cx.theme().colors().text_muted)
+                                                            .child("Removed")
+                                                    ),
+                                            ),
+                                    ),
+                            ),
+                    )
+                    .child(
+                        // Additional info
+                        h_flex()
+                            .gap_4()
+                            .child(
+                                v_flex()
+                                    .gap_1()
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child("Created")
+                                    )
+                                    .child(
+                                        div()
+                                                            .child(SharedString::from(
+                                                self.pr.created_at.format("%Y-%m-%d %H:%M").to_string()
+                                            ))
+                                    ),
+                            )
+                            .child(
+                                v_flex()
+                                    .gap_1()
+                                    .child(
+                                        div()
+                                                            .text_color(cx.theme().colors().text_muted)
+                                            .child("Updated")
+                                    )
+                                    .child(
+                                        div()
+                                                            .child(SharedString::from(
+                                                self.pr.updated_at.format("%Y-%m-%d %H:%M").to_string()
+                                            ))
+                                    ),
+                            )
+                            .when(self.pr.assignees.len() > 0, |this| {
+                                this.child(
+                                    v_flex()
+                                        .gap_1()
+                                        .child(
+                                            div()
+                                                                    .text_color(cx.theme().colors().text_muted)
+                                                .child("Assignees")
+                                        )
+                                        .child(
+                                            div()
+                                                                    .child(SharedString::from(
+                                                    self.pr.assignees.iter()
+                                                        .map(|a| a.login.as_str())
+                                                        .collect::<Vec<_>>()
+                                                        .join(", ")
+                                                ))
+                                        ),
+                                )
+                            })
+                            .when(self.pr.labels.len() > 0, |this| {
+                                this.child(
+                                    v_flex()
+                                        .gap_1()
+                                        .child(
+                                            div()
+                                                                    .text_color(cx.theme().colors().text_muted)
+                                                .child("Labels")
+                                        )
+                                        .child(
+                                            h_flex()
+                                                .gap_1()
+                                                .children(self.pr.labels.iter().map(|label| {
+                                                    div()
+                                                        .px_2()
+                                                        .py_1()
+                                                        .rounded_md()
+                                                        .bg(theme.colors().element_background)
+                                                        .child(
+                                                            div()
+                                                                                                    .child(SharedString::from(label.name.clone()))
+                                                        )
+                                                })),
+                                        ),
+                                )
+                            }),
+                    )
+                    .child(
+                        // Reviewers section
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("Review Status")
+                            )
+                            .child(
+                                div()
+                                    .p_3()
+                                    .rounded_md()
+                                    .bg(theme.colors().element_background)
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .child(
+                                        v_flex()
+                                            .gap_2()
+                                            .when(self.pr.requested_reviewers.len() > 0, |this| {
+                                                this.child(
+                                                    v_flex()
+                                                        .gap_1()
+                                                        .child(
+                                                            h_flex()
+                                                                .gap_2()
+                                                                .items_center()
+                                                                .child(Icon::new(IconName::Person).size(IconSize::Small).color(Color::Muted))
+                                                                .child(
+                                                                    div()
+                                                                                                                    .text_color(cx.theme().colors().text_muted)
+                                                                        .child("Review Requested")
+                                                                )
+                                                        )
+                                                        .child(
+                                                            h_flex()
+                                                                .gap_2()
+                                                                .flex_wrap()
+                                                                .children(self.pr.requested_reviewers.iter().map(|reviewer| {
+                                                                    div()
+                                                                        .px_2()
+                                                                        .py_1()
+                                                                        .rounded_md()
+                                                                        .bg(theme.colors().element_hover)
+                                                                        .child(
+                                                                            div()
+                                                                                                                                    .child(SharedString::from(reviewer.login.clone()))
+                                                                        )
+                                                                }))
+                                                        )
+                                                )
+                                            })
+                                            .child(
+                                                h_flex()
+                                                    .gap_2()
+                                                    .items_center()
+                                                    .child(self.render_merge_status_icon(cx))
+                                                    .child(self.render_merge_status_text(cx))
+                                            )
+                                    )
+                            )
+                    )
+                    .child(
+                        // Commit information
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("Commits")
+                            )
+                            .child(
+                                div()
+                                    .p_3()
+                                    .rounded_md()
+                                    .bg(theme.colors().element_background)
+                                    .border_1()
+                                    .border_color(theme.colors().border)
+                                    .child(
+                                        h_flex()
+                                            .gap_4()
+                                            .items_center()
+                                            .child(
+                                                h_flex()
+                                                    .gap_1()
+                                                    .items_center()
+                                                    .child(Icon::new(IconName::GitBranch).size(IconSize::Small).color(Color::Muted))
+                                                    .child(
+                                                        div()
+                                                                                            .child(SharedString::from(format!("{} commits", self.pr.commits)))
+                                                    )
+                                            )
+                                            .child(
+                                                ButtonLike::new("view-commits")
+                                                    .style(ButtonStyle::Subtle)
+                                                    .child(h_flex().gap_1()
+                                                        .child(Icon::new(IconName::HistoryRerun).size(IconSize::Small))
+                                                        .child(Label::new("View Commits").buffer_font(cx))
+                                                    )
+                                                                            .on_click(cx.listener(|this, _, _window, cx| {
+                                                        let commits_url = format!("{}/commits", this.pr.html_url);
+                                                        cx.open_url(&commits_url);
+                                                    }))
+                                            )
+                                    )
+                            )
+                    )
+                    .child(
+                        // Actions section
+                        v_flex()
+                            .gap_2()
+                            .child(
+                                div()
+                                            .text_color(cx.theme().colors().text_muted)
+                                    .child("Actions")
+                            )
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .flex_wrap()
+                                    .child(
+                                        ButtonLike::new("view-on-github")
+                                            .style(ButtonStyle::Outlined)
+                                            .child(h_flex().gap_1()
+                                                .child(Icon::new(IconName::Github).size(IconSize::Small))
+                                                .child(Label::new("View on GitHub").buffer_font(cx))
+                                            )
+                                                            .on_click(cx.listener(|this, _, _window, cx| {
+                                                cx.open_url(this.pr.html_url.as_str());
+                                            }))
+                                    )
+                                    .child(
+                                        ButtonLike::new("view-diff")
+                                            .style(ButtonStyle::Outlined)
+                                            .child(h_flex().gap_1()
+                                                .child(Icon::new(IconName::Diff).size(IconSize::Small))
+                                                .child(Label::new("View Files").buffer_font(cx))
+                                            )
+                                                            .on_click(cx.listener(|this, _, _window, cx| {
+                                                let diff_url = format!("{}/files", this.pr.html_url);
+                                                cx.open_url(&diff_url);
+                                            }))
+                                    )
+                                    .child(
+                                        ButtonLike::new("view-checks")
+                                            .style(ButtonStyle::Outlined)
+                                            .child(h_flex().gap_1()
+                                                .child(Icon::new(IconName::Check).size(IconSize::Small))
+                                                .child(Label::new("View Checks").buffer_font(cx))
+                                            )
+                                                            .on_click(cx.listener(|this, _, _window, cx| {
+                                                let checks_url = format!("{}/checks", this.pr.html_url);
+                                                cx.open_url(&checks_url);
+                                            }))
+                                    )
+                            ),
+                    )
+            )
+            .children(self.context_menu.as_ref().map(|(menu, position, _)| {
+                deferred(
+                    anchored()
+                        .position(*position)
+                        .anchor(gpui::Corner::TopLeft)
+                        .child(menu.clone()),
+                )
+                .with_priority(1)
+            }))
+    }
+}
+
+impl PullRequestDetailView {
+    fn format_date(&self, date: &chrono::DateTime<chrono::Utc>) -> String {
+        let now = chrono::Utc::now();
+        let duration = now.signed_duration_since(*date);
+        
+        if duration.num_days() > 7 {
+            date.format("%b %d, %Y").to_string()
+        } else if duration.num_days() > 0 {
+            format!("{} days ago", duration.num_days())
+        } else if duration.num_hours() > 0 {
+            format!("{} hours ago", duration.num_hours())
+        } else if duration.num_minutes() > 0 {
+            format!("{} minutes ago", duration.num_minutes())
+        } else {
+            "Just now".to_string()
+        }
+    }
+
+    fn render_state_badge(&self, cx: &Context<Self>) -> impl IntoElement {
+        let (icon, color, label) = match self.pr.state {
+            PullRequestState::Open => {
+                if self.pr.draft {
+                    (IconName::GitBranch, Color::Muted, "Draft")
+                } else {
+                    (IconName::GitBranch, Color::Success, "Open")
+                }
+            }
+            PullRequestState::Closed => (IconName::Close, Color::Error, "Closed"),
+            PullRequestState::Merged => (IconName::Check, Color::Accent, "Merged"),
+        };
+        
+        h_flex()
+            .gap_1()
+            .px_2()
+            .py_1()
+            .rounded_md()
+            .bg(cx.theme().colors().element_background)
+            .child(Icon::new(icon).size(IconSize::Small).color(color))
+            .child(
+                div()
+                    .text_buffer(cx)
+                    .text_color(color.color(cx))
+                    .child(label)
+            )
+    }
+
+    fn render_merge_status_icon(&self, _cx: &Context<Self>) -> impl IntoElement {
+        let (icon, color) = match self.pr.mergeable {
+            Some(true) => (IconName::Check, Color::Success),
+            Some(false) => (IconName::Close, Color::Error),
+            None => (IconName::LoadCircle, Color::Muted),
+        };
+        
+        Icon::new(icon).size(IconSize::Small).color(color)
+    }
+
+    fn render_merge_status_text(&self, _cx: &Context<Self>) -> impl IntoElement {
+        let (text, color) = match (&self.pr.mergeable, &self.pr.mergeable_state) {
+            (Some(true), Some(state)) => match state.as_str() {
+                "clean" => ("Ready to merge", Color::Success),
+                "has_hooks" => ("Merge checks pending", Color::Muted),
+                "unstable" => ("Merge checks running", Color::Muted),
+                _ => ("Mergeable", Color::Success),
+            },
+            (Some(false), Some(state)) => match state.as_str() {
+                "blocked" => ("Merge blocked", Color::Error),
+                "behind" => ("Branch is behind", Color::Error),
+                "dirty" => ("Merge conflicts", Color::Error),
+                _ => ("Cannot merge", Color::Error),
+            },
+            (None, _) => ("Checking merge status...", Color::Muted),
+            _ => ("Unknown merge status", Color::Muted),
+        };
+        
+        div()
+            .text_buffer(_cx)
+            .text_color(color.color(_cx))
+            .child(text)
+    }
+}
+
+impl Focusable for PullRequestDetailView {
+    fn focus_handle(&self, _cx: &App) -> FocusHandle {
+        self.focus_handle.clone()
+    }
+}
+
+impl Item for PullRequestDetailView {
+    type Event = ();
+
+    fn tab_content_text(&self, _tab_index: usize, _cx: &App) -> SharedString {
+        SharedString::from(format!("PR #{}", self.pr.number))
+    }
+
+    fn to_item_events(_event: &Self::Event, _f: impl FnMut(workspace::item::ItemEvent)) {}
+}
+
+impl EventEmitter<()> for PullRequestDetailView {}
\ No newline at end of file
diff --git a/crates/pull_requests_ui/src/pr_detail_view_complex.rs.bak b/crates/pull_requests_ui/src/pr_detail_view_complex.rs.bak
new file mode 100644
index 0000000000..7d4ef8754f
--- /dev/null
+++ b/crates/pull_requests_ui/src/pr_detail_view_complex.rs.bak
@@ -0,0 +1,394 @@
+use gpui::{
+    actions, div, px, rems, App, Context, Entity, EventEmitter, FocusHandle, Focusable, InteractiveElement,
+    IntoElement, ParentElement, Render, ScrollHandle, SharedString, StatefulInteractiveElement,
+    Styled, Window,
+};
+use pull_requests::{
+    models::{CheckRunConclusion, CheckRunStatus, CheckState},
+    PullRequest, PullRequestComment, PullRequestReview, ReviewState,
+};
+use theme::ActiveTheme;
+use ui::{
+    h_flex, prelude::*, v_flex, Avatar, Button, ButtonCommon, ButtonStyle, Clickable, Color,
+    FluentBuilder, Icon, IconName, IconSize, Label, LabelCommon, LabelSize, Tab, TabBar,
+};
+use workspace::item::{Item, ItemHandle};
+
+actions!(pr_detail, [SubmitReview, AddComment, ApprovePullRequest]);
+
+pub fn init(_cx: &mut App) {}
+
+pub struct PullRequestDetailView {
+    pr: PullRequest,
+    comments: Vec<PullRequestComment>,
+    reviews: Vec<PullRequestReview>,
+    focus_handle: FocusHandle,
+    scroll_handle: ScrollHandle,
+    active_tab: DetailTab,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq)]
+enum DetailTab {
+    Overview,
+    Conversation,
+    Files,
+    Checks,
+}
+
+impl PullRequestDetailView {
+    pub fn new(pr: PullRequest, cx: &mut Context<Self>) -> Self {
+        let focus_handle = cx.focus_handle();
+
+        Self {
+            pr,
+            comments: Vec::new(),
+            reviews: Vec::new(),
+            focus_handle,
+            scroll_handle: ScrollHandle::new(),
+            active_tab: DetailTab::Overview,
+        }
+    }
+
+    fn render_overview(&self) -> impl IntoElement {
+        let pr = &self.pr;
+
+        v_flex()
+            .gap_4()
+            .p_4()
+            .child(
+                h_flex()
+                    .gap_2()
+                    .child(Avatar::new(pr.user.avatar_url.to_string()))
+                    .child(
+                        v_flex()
+                            .gap_1()
+                            .child(Label::new(SharedString::from(pr.user.login.clone())))
+                            .child(
+                                Label::new(SharedString::from(format!(
+                                    "Created {}",
+                                    pr.created_at.format("%b %d, %Y")
+                                )))
+                                .size(LabelSize::Small)
+                                .color(Color::Muted),
+                            ),
+                    ),
+            )
+            .child(
+                v_flex()
+                    .gap_2()
+                    .child(Label::new("Description").size(LabelSize::Small))
+                    .child(
+                        div()
+                            .p_2()
+                            .rounded_md()
+                            .bg(gpui::rgb(0x1a1a1a))
+                            .child(Label::new(SharedString::from(pr.body.clone()))),
+                    ),
+            )
+            .child(
+                v_flex()
+                    .gap_2()
+                    .child(Label::new("Details").size(LabelSize::Small))
+                    .child(
+                        v_flex()
+                            .gap_1()
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(Label::new("Branch:").size(LabelSize::Small))
+                                    .child(
+                                        Label::new(SharedString::from(pr.head.ref_name.clone()))
+                                            .size(LabelSize::Small),
+                                    ),
+                            )
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(Label::new("Into:").size(LabelSize::Small))
+                                    .child(
+                                        Label::new(SharedString::from(pr.base.ref_name.clone()))
+                                            .size(LabelSize::Small),
+                                    ),
+                            )
+                            .child(
+                                h_flex()
+                                    .gap_2()
+                                    .child(Label::new("Changes:").size(LabelSize::Small))
+                                    .child(
+                                        Label::new(SharedString::from(format!(
+                                            "+{} -{} in {} files",
+                                            pr.additions, pr.deletions, pr.changed_files
+                                        )))
+                                        .size(LabelSize::Small)
+                                        .color(Color::Success),
+                                    ),
+                            ),
+                    ),
+            )
+            .when(!pr.labels.is_empty(), |this| {
+                this.child(
+                    v_flex()
+                        .gap_2()
+                        .child(Label::new("Labels").size(LabelSize::Small))
+                        .child(h_flex().gap_1().children(pr.labels.iter().map(|label| {
+                            div()
+                                .px_2()
+                                .py_1()
+                                .rounded_md()
+                                .bg(gpui::rgb(0x2a2a2a))
+                                .child(
+                                    Label::new(SharedString::from(label.name.clone()))
+                                        .size(LabelSize::XSmall),
+                                )
+                        }))),
+                )
+            })
+    }
+
+    fn render_conversation(&self) -> impl IntoElement {
+        v_flex()
+            .gap_3()
+            .p_4()
+            .children(self.comments.iter().map(|comment| {
+                div().p_3().rounded_md().bg(gpui::rgb(0x1a1a1a)).child(
+                    v_flex()
+                        .gap_2()
+                        .child(
+                            h_flex()
+                                .gap_2()
+                                .child(
+                                    Avatar::new(comment.user.avatar_url.to_string())
+                                        .size(rems(1.5)),
+                                )
+                                .child(
+                                    v_flex()
+                                        .gap_1()
+                                        .child(
+                                            Label::new(SharedString::from(
+                                                comment.user.login.clone(),
+                                            ))
+                                            .size(LabelSize::Small),
+                                        )
+                                        .child(
+                                            Label::new(SharedString::from(
+                                                comment.created_at.format("%b %d at %H:%M"),
+                                            ))
+                                            .size(LabelSize::XSmall)
+                                            .color(Color::Muted),
+                                        ),
+                                ),
+                        )
+                        .child(Label::new(SharedString::from(comment.body.clone()))),
+                )
+            }))
+            .when(self.comments.is_empty(), |this| {
+                this.child(
+                    div()
+                        .p_4()
+                        .child(Label::new("No comments yet").color(Color::Muted)),
+                )
+            })
+    }
+
+    fn render_files(&self) -> impl IntoElement {
+        v_flex()
+            .gap_2()
+            .p_4()
+            .child(Label::new(SharedString::from(format!(
+                "{} files changed",
+                self.pr.changed_files
+            ))))
+            .child(
+                div()
+                    .p_4()
+                    .child(Label::new("File diff view coming soon").color(Color::Muted)),
+            )
+    }
+
+    fn render_checks(&self) -> impl IntoElement {
+        let checks = &self.pr.checks;
+
+        v_flex()
+            .gap_3()
+            .p_4()
+            .child(
+                h_flex()
+                    .gap_2()
+                    .child(
+                        match checks.state {
+                            CheckState::Success => Icon::new(IconName::Check).color(Color::Success),
+                            CheckState::Failure => Icon::new(IconName::XCircle).color(Color::Error),
+                            CheckState::Pending => {
+                                Icon::new(IconName::Circle).color(Color::Warning)
+                            }
+                            CheckState::Error => Icon::new(IconName::Warning).color(Color::Error),
+                        }
+                        .size(IconSize::Small),
+                    )
+                    .child(Label::new(SharedString::from(format!(
+                        "{} checks",
+                        checks.total_count
+                    )))),
+            )
+            .children(checks.check_runs.iter().map(|check| {
+                h_flex()
+                    .gap_2()
+                    .p_2()
+                    .rounded_md()
+                    .bg(gpui::rgb(0x1a1a1a))
+                    .child(
+                        match check.status {
+                            CheckRunStatus::Completed => match &check.conclusion {
+                                Some(CheckRunConclusion::Success) => {
+                                    Icon::new(IconName::Check).color(Color::Success)
+                                }
+                                Some(CheckRunConclusion::Failure) => {
+                                    Icon::new(IconName::XCircle).color(Color::Error)
+                                }
+                                _ => Icon::new(IconName::Circle).color(Color::Muted),
+                            },
+                            CheckRunStatus::InProgress => {
+                                Icon::new(IconName::Circle).color(Color::Warning)
+                            }
+                            CheckRunStatus::Queued => {
+                                Icon::new(IconName::Circle).color(Color::Muted)
+                            }
+                        }
+                        .size(IconSize::Small),
+                    )
+                    .child(Label::new(SharedString::from(check.name.clone())))
+            }))
+    }
+}
+
+impl Render for PullRequestDetailView {
+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
+        let pr = &self.pr;
+
+        v_flex()
+            .size_full()
+            .child(
+                v_flex()
+                    .gap_2()
+                    .p_3()
+                    .border_b_1()
+                    .border_color(cx.theme().colors().border)
+                    .child(
+                        h_flex()
+                            .gap_2()
+                            .child(Label::new(SharedString::from(pr.title.clone())))
+                            .child(
+                                Label::new(SharedString::from(format!("#{}", pr.number)))
+                                    .color(Color::Muted),
+                            ),
+                    )
+                    .child(
+                        TabBar::new("pr_detail_tabs")
+                            .child(
+                                Tab::new("overview", DetailTab::Overview, "Overview")
+                                    .selected(self.active_tab == DetailTab::Overview)
+                                    .on_click(cx.listener(|this, _, _window, cx| {
+                                        this.active_tab = DetailTab::Overview;
+                                        cx.notify();
+                                    })),
+                            )
+                            .child(
+                                Tab::new("conversation", DetailTab::Conversation, "Conversation")
+                                    .selected(self.active_tab == DetailTab::Conversation)
+                                    .on_click(cx.listener(|this, _, _window, cx| {
+                                        this.active_tab = DetailTab::Conversation;
+                                        cx.notify();
+                                    })),
+                            )
+                            .child(
+                                Tab::new("files", DetailTab::Files, "Files Changed")
+                                    .selected(self.active_tab == DetailTab::Files)
+                                    .on_click(cx.listener(|this, _, _window, cx| {
+                                        this.active_tab = DetailTab::Files;
+                                        cx.notify();
+                                    })),
+                            )
+                            .child(
+                                Tab::new("checks", DetailTab::Checks, "Checks")
+                                    .selected(self.active_tab == DetailTab::Checks)
+                                    .on_click(cx.listener(|this, _, _window, cx| {
+                                        this.active_tab = DetailTab::Checks;
+                                        cx.notify();
+                                    })),
+                            ),
+                    ),
+            )
+            .child(
+                div()
+                    .flex_1()
+                    .overflow_y_scroll()
+                    .track_scroll(&self.scroll_handle)
+                    .child(match self.active_tab {
+                        DetailTab::Overview => self.render_overview(),
+                        DetailTab::Conversation => self.render_conversation(),
+                        DetailTab::Files => self.render_files(),
+                        DetailTab::Checks => self.render_checks(),
+                    }),
+            )
+            .child(
+                h_flex()
+                    .gap_2()
+                    .p_3()
+                    .border_t_1()
+                    .border_color(cx.theme().colors().border)
+                    .child(
+                        Button::new("comment", "Comment")
+                            .style(ButtonStyle::Filled)
+                            .on_click(cx.listener(|_, _, _window, cx| {
+                                cx.spawn(|_, cx| async move {
+                                    cx.prompt_message("Comment feature coming soon!");
+                                    Ok(())
+                                })
+                                .detach();
+                            })),
+                    )
+                    .child(
+                        Button::new("approve", "Approve")
+                            .style(ButtonStyle::Subtle)
+                            .on_click(cx.listener(|_, _, _window, cx| {
+                                cx.spawn(|_, cx| async move {
+                                    cx.prompt_message("Approve feature coming soon!");
+                                    Ok(())
+                                })
+                                .detach();
+                            })),
+                    )
+                    .child(
+                        Button::new("merge", "Merge")
+                            .style(ButtonStyle::Filled)
+                            .color(Color::Success)
+                            .disabled(pr.mergeable != Some(true))
+                            .on_click(cx.listener(|_, _, _window, cx| {
+                                cx.spawn(|_, cx| async move {
+                                    cx.prompt_message("Merge feature coming soon!");
+                                    Ok(())
+                                })
+                                .detach();
+                            })),
+                    ),
+            )
+    }
+}
+
+impl Focusable for PullRequestDetailView {
+    fn focus_handle(&self, _cx: &App) -> FocusHandle {
+        self.focus_handle.clone()
+    }
+}
+
+impl Item for PullRequestDetailView {
+    type Event = ();
+
+    fn tab_content_text(&self, _tab_index: usize, _cx: &App) -> SharedString {
+        SharedString::from(format!("PR #{}", self.pr.number))
+    }
+
+    fn to_item_events(_event: &Self::Event, _f: impl FnMut(workspace::item::ItemEvent)) {}
+}
+
+impl EventEmitter<()> for PullRequestDetailView {}
diff --git a/crates/pull_requests_ui/src/pr_list_panel.rs b/crates/pull_requests_ui/src/pr_list_panel.rs
new file mode 100644
index 0000000000..06f5a12470
--- /dev/null
+++ b/crates/pull_requests_ui/src/pr_list_panel.rs
@@ -0,0 +1,985 @@
+use anyhow::Result;
+use fs;
+use git::{parse_git_remote_url, GitHostingProviderRegistry, ParsedGitRemote};
+use gpui::{
+    actions, div, px, App, AsyncWindowContext, ClipboardItem, Context, DismissEvent, Entity,
+    EventEmitter, FocusHandle, Focusable, InteractiveElement, IntoElement, ParentElement, Pixels,
+    Render, SharedString, Styled, WeakEntity, Window,
+};
+use menu::SelectNext;
+use project::Project;
+use pull_requests::{
+    GithubAuth, GithubPrClient, PullRequest, PullRequestManager, PullRequestState, 
+    PullRequestStore, PullRequestStoreEvent,
+};
+use schemars::JsonSchema;
+use serde::{Deserialize, Serialize};
+use settings::{Settings, SettingsKey, SettingsSources, SettingsUi};
+use std::sync::Arc;
+use theme::{ActiveTheme, observe_buffer_font_size_adjustment};
+use ui::{
+    h_flex, prelude::*, v_flex, Clickable, Color, FluentBuilder, Icon, IconButton, 
+    IconName, IconSize, Label, LabelCommon, LabelSize, ListItem, ListItemSpacing, Tooltip,
+};
+use util::command::new_smol_command;
+use workspace::{
+    dock::{DockPosition, Panel, PanelEvent},
+    ItemHandle, Workspace,
+};
+use zed_actions::{DecreaseBufferFontSize, IncreaseBufferFontSize, ResetBufferFontSize};
+
+
+actions!(
+    pull_requests,
+    [
+        ToggleFocus,
+        RefreshPullRequests,
+        CheckoutPullRequest,
+        OpenInBrowser,
+        CopyPullRequestUrl,
+        CreatePullRequest,
+        LoginWithGithub,
+    ]
+);
+
+pub fn init(cx: &mut App) {
+    cx.observe_new(|workspace: &mut Workspace, _, _| {
+        workspace.register_action(|workspace, _: &ToggleFocus, window, cx| {
+            workspace.toggle_panel_focus::<PullRequestListPanel>(window, cx);
+        });
+    })
+    .detach();
+}
+
+pub struct PullRequestListPanel {
+    project: Entity<Project>,
+    manager: Entity<PullRequestManager>,
+    workspace: WeakEntity<Workspace>,
+    focus_handle: FocusHandle,
+    selected_index: usize,
+    filter_state: FilterState,
+    fs: Arc<dyn fs::Fs>,
+    _font_size_subscription: gpui::Subscription,
+    width: Option<Pixels>,
+    has_auto_fetched: bool,
+    is_loading: bool,
+    _subscriptions: Vec<gpui::Subscription>,
+}
+
+#[derive(Default)]
+struct FilterState {
+    show_open: bool,
+    show_closed: bool,
+    show_merged: bool,
+    show_drafts: bool,
+}
+
+impl PullRequestListPanel {
+    pub async fn load(
+        workspace: WeakEntity<Workspace>,
+        mut cx: AsyncWindowContext,
+    ) -> Result<Entity<Self>> {
+        // For now, skip persistence and just create a new panel
+        workspace.update_in(&mut cx, |workspace, window, cx| {
+            let panel = cx.new(|cx| Self::new(workspace, window, cx));
+            panel
+        })
+    }
+    
+
+    pub fn new(workspace: &Workspace, _window: &mut Window, cx: &mut Context<Self>) -> Self {
+        log::info!("Creating new PullRequestListPanel");
+        let project = workspace.project().clone();
+        let focus_handle = cx.focus_handle();
+        let workspace_weak = workspace.weak_handle();
+
+        let http_client = project.read(cx).client().http_client();
+        
+        // Get authentication token from GithubAuth
+        let token = GithubAuth::global(cx).token().map(|t| t.to_string());
+        let api_client = Arc::new(GithubPrClient::new_with_auth(http_client, token));
+        let fs = workspace.app_state().fs.clone();
+
+        // Create the store
+        let store = cx.new(|cx| PullRequestStore::new(api_client.clone(), cx));
+
+        // Create the manager
+        let manager =
+            cx.new(|cx| PullRequestManager::new_with_store(project.clone(), store, api_client, cx));
+
+        // Subscribe to manager events
+        let subscriptions =
+            vec![cx.subscribe(&manager.read(cx).store().clone(), Self::on_store_event)];
+
+        // Subscribe to font size changes to trigger re-rendering
+        let font_size_subscription = observe_buffer_font_size_adjustment(cx, |_this, cx| {
+            log::info!("PR panel: Font size changed, re-rendering");
+            cx.notify();
+        });
+
+        // Don't auto-fetch on startup - wait for panel to become active
+        // This prevents fetching from the wrong repository
+
+        Self {
+            project,
+            manager,
+            workspace: workspace_weak,
+            focus_handle,
+            selected_index: 0,
+            filter_state: FilterState {
+                show_open: true,
+                show_closed: false,
+                show_merged: false,
+                show_drafts: true,
+            },
+            fs,
+            _font_size_subscription: font_size_subscription,
+            width: None,
+            has_auto_fetched: false,
+            is_loading: false,
+            _subscriptions: subscriptions,
+        }
+    }
+
+    fn on_store_event(
+        &mut self,
+        _store: Entity<PullRequestStore>,
+        event: &PullRequestStoreEvent,
+        cx: &mut Context<Self>,
+    ) {
+        match event {
+            PullRequestStoreEvent::PullRequestsUpdated
+            | PullRequestStoreEvent::ActivePullRequestChanged => {
+                cx.notify();
+            }
+        }
+    }
+
+    fn refresh_pull_requests(&mut self, _: &RefreshPullRequests, _window: &mut Window, cx: &mut Context<Self>) {
+        // Get the actual project's working directory
+        let project = self.project.clone();
+        let cwd = project.read(cx)
+            .worktrees(cx)
+            .next()
+            .and_then(|worktree| {
+                let worktree = worktree.read(cx);
+                worktree.root_entry()
+                    .filter(|entry| entry.is_dir())
+                    .map(|_| worktree.abs_path().to_path_buf())
+            });
+        
+        let Some(cwd) = cwd else {
+            log::warn!("PR panel refresh: No project directory found");
+            return;
+        };
+        
+        log::info!("PR panel refresh: Project directory: {:?}", cwd);
+        
+        let manager = self.manager.clone();
+        cx.spawn(async move |this, cx| {
+            
+            // Get origin remote first to determine the actual repository
+            let origin_url = if let Ok(output) = new_smol_command("git")
+                .current_dir(&cwd)
+                .args(&["remote", "get-url", "origin"])
+                .output()
+                .await
+            {
+                if output.status.success() {
+                    String::from_utf8_lossy(&output.stdout).trim().to_string()
+                } else {
+                    String::new()
+                }
+            } else {
+                String::new()
+            };
+            
+            // Use origin by default
+            let mut remote_url = origin_url.clone();
+            
+            // Only check upstream if this appears to be a Zed fork
+            // Be specific: only match URLs ending with /zed or /zed.git
+            let is_zed_fork = !origin_url.is_empty() && 
+               !origin_url.contains("zed-industries") &&
+               (origin_url.ends_with("/zed.git") || 
+                origin_url.ends_with("/zed") ||
+                origin_url.contains(":zed.git") ||
+                origin_url.contains(":zed"));
+                
+            if is_zed_fork {
+                log::info!("Refresh: Detected Zed fork (origin: {}), checking for upstream", origin_url);
+                // This is a Zed fork, try to use upstream
+                if let Ok(output) = new_smol_command("git")
+                    .current_dir(&cwd)
+                    .args(&["remote", "get-url", "upstream"])
+                    .output()
+                    .await
+                {
+                    if output.status.success() {
+                        let upstream_url = String::from_utf8_lossy(&output.stdout).trim().to_string();
+                        if !upstream_url.is_empty() && upstream_url.contains("zed-industries/zed") {
+                            remote_url = upstream_url;
+                        }
+                    }
+                }
+            }
+            
+            // If still no remote found, fallback
+            if remote_url.is_empty() {
+                let _ = manager.update(cx, |manager, cx| manager.refresh_pull_requests(cx))?;
+                return Ok::<(), anyhow::Error>(());
+            }
+            
+            // Parse the remote URL to get owner/repo
+            let parsed_remote = this.update(cx, |_this, cx| {
+                let provider_registry = GitHostingProviderRegistry::global(cx);
+                parse_git_remote_url(provider_registry, &remote_url)
+                    .map(|(_provider, parsed_remote)| parsed_remote)
+            })?;
+            
+            if let Some(remote) = parsed_remote {
+                // Fetch PRs directly from the detected repository (including Zed)
+                let _ = manager.update(cx, |manager, cx| {
+                    manager.store().update(cx, |store, cx| {
+                        store.fetch_pull_requests(remote, cx)
+                    })
+                })?;
+            } else {
+                // Fallback to manager's method if parsing fails
+                let _ = manager.update(cx, |manager, cx| manager.refresh_pull_requests(cx))?;
+            }
+            
+            Ok::<(), anyhow::Error>(())
+        }).detach_and_log_err(cx);
+    }
+
+    fn checkout_pull_request(&mut self, _: &CheckoutPullRequest, _window: &mut Window, cx: &mut Context<Self>) {
+        let prs = self.filtered_pull_requests(cx);
+
+        if let Some(pr) = prs.get(self.selected_index) {
+            self.manager
+                .update(cx, |manager, cx| {
+                    manager.checkout_pull_request(pr.number, cx)
+                })
+                .log_err();
+        }
+    }
+
+    fn open_in_browser(&mut self, _: &OpenInBrowser, _window: &mut Window, cx: &mut Context<Self>) {
+        let prs = self.filtered_pull_requests(cx);
+        if let Some(pr) = prs.get(self.selected_index) {
+            cx.open_url(pr.html_url.as_str());
+        }
+    }
+
+    fn copy_url(&mut self, _: &CopyPullRequestUrl, _window: &mut Window, cx: &mut Context<Self>) {
+        let prs = self.filtered_pull_requests(cx);
+        if let Some(pr) = prs.get(self.selected_index) {
+            cx.write_to_clipboard(ClipboardItem::new_string(pr.html_url.to_string()));
+        }
+    }
+
+    fn login_with_github(&mut self, _: &LoginWithGithub, cx: &mut Context<Self>) {
+        // Open GitHub personal access token page directly
+        let url = "https://github.com/settings/tokens/new?scopes=repo,read:user&description=Zed%20Pull%20Requests";
+        cx.open_url(url);
+        
+        // Show instructions
+        cx.spawn(async move |this, cx| {
+            this.update(cx, |this, cx| {
+                this.manager.update(cx, |manager, cx| {
+                    manager.store().update(cx, |store, _cx| {
+                        store.error = Some(
+                            "Opening GitHub to create a token. After creating the token:\n\
+                            1. Copy the token\n\
+                            2. Run: export GITHUB_TOKEN=<your_token>\n\
+                            3. Restart Zed".to_string()
+                        );
+                    });
+                });
+                cx.notify();
+            })?;
+            Ok::<(), anyhow::Error>(())
+        })
+        .detach();
+    }
+
+    fn open_pr_detail(&mut self, pr: PullRequest, window: &mut Window, cx: &mut Context<Self>) {
+        // Open PR detail view natively in Zed
+        if let Some(workspace) = self.workspace.upgrade() {
+            workspace.update(cx, |workspace, cx| {
+                use crate::pr_detail_view::PullRequestDetailView;
+                
+                // Check if a tab for this PR already exists across all panes
+                let pr_number = pr.number;
+                let all_items: Vec<_> = workspace.items(cx).collect();
+                
+                let existing_view = all_items.into_iter()
+                    .find_map(|item| {
+                        let downcast = item.downcast::<PullRequestDetailView>();
+                        if let Some(view) = &downcast {
+                            let view_pr_number = view.read(cx).pr.number;
+                            if view_pr_number == pr_number {
+                                return downcast;
+                            }
+                        }
+                        None
+                    });
+                
+                if let Some(view) = existing_view {
+                    // Check if already active before activating to prevent re-render
+                    let is_active = workspace.active_item(cx).map_or(false, |item| {
+                        item.item_id() == view.item_id()
+                    });
+                    
+                    if !is_active {
+                        // Only activate if not already active
+                        workspace.activate_item(&view, true, false, window, cx);
+                    }
+                    // Always focus to ensure user sees the tab
+                    window.focus(&view.focus_handle(cx));
+                } else {
+                    // Create new tab and focus it
+                    let detail_view = cx.new(|cx| {
+                        PullRequestDetailView::new_with_project(pr.clone(), &self.project, cx)
+                            .unwrap_or_else(|e| {
+                                log::error!("Failed to create PR detail view: {}", e);
+                                // Fallback: create a basic view without API access
+                                let http_client = self.project.read(cx).client().http_client();
+                                let remote = ParsedGitRemote {
+                                    owner: "unknown".into(),
+                                    repo: "unknown".into()
+                                };
+                                PullRequestDetailView::new_with_authentication(pr.clone(), http_client, remote, cx)
+                            })
+                    });
+                    let focus_handle = detail_view.focus_handle(cx);
+                    workspace.add_item_to_active_pane(Box::new(detail_view), None, true, window, cx);
+                    window.focus(&focus_handle);
+                }
+            });
+        }
+        
+        // Also fetch the full PR details to update comment count
+        let manager = self.manager.clone();
+        let pr_number = pr.number;
+        
+        if let Ok(remote) = self.manager.read(cx).get_current_remote(cx) {
+            let api_client = manager.read(cx).api_client();
+            
+            cx.spawn(async move |this, cx| {
+                // Fetch the full PR details with accurate comment counts
+                let full_pr = api_client.get_pull_request(&remote, pr_number).await?;
+                
+                // Update the PR in the store with accurate data
+                this.update(cx, |this, cx| {
+                    this.manager.update(cx, |manager, cx| {
+                        manager.store().update(cx, |store, _cx| {
+                            store.update_pull_request(full_pr);
+                        });
+                    });
+                    cx.notify();
+                })?;
+                
+                Ok::<(), anyhow::Error>(())
+            })
+            .detach_and_log_err(cx);
+        }
+    }
+
+    fn create_pull_request(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        // Open GitHub PR creation page with current branch
+        if let Ok(remote) = self.manager.read(cx).get_current_remote(cx) {
+            cx.spawn(async move |this, cx| {
+                // Get current branch
+                let cwd = match std::env::current_dir() {
+                    Ok(dir) => dir,
+                    Err(_) => return Ok::<(), anyhow::Error>(()),
+                };
+                
+                // Get current branch name
+                let branch_output = match new_smol_command("git")
+                    .current_dir(&cwd)
+                    .args(&["branch", "--show-current"])
+                    .output()
+                    .await
+                {
+                    Ok(output) if output.status.success() => output,
+                    _ => {
+                        // Fallback to basic compare URL
+                        this.update(cx, |_this, cx| {
+                            let url = format!("https://github.com/{}/{}/compare", 
+                                remote.owner.as_ref(), remote.repo.as_ref());
+                            cx.open_url(&url);
+                        })?;
+                        return Ok::<(), anyhow::Error>(());
+                    }
+                };
+                
+                let current_branch = String::from_utf8_lossy(&branch_output.stdout).trim().to_string();
+                
+                // Get default branch (usually main or master)
+                let default_branch_output = match new_smol_command("git")
+                    .current_dir(&cwd)
+                    .args(&["symbolic-ref", "refs/remotes/origin/HEAD"])
+                    .output()
+                    .await
+                {
+                    Ok(output) if output.status.success() => {
+                        let ref_path = String::from_utf8_lossy(&output.stdout).trim().to_string();
+                        // Extract branch name from refs/remotes/origin/branch_name
+                        ref_path.split('/').last().unwrap_or("main").to_string()
+                    },
+                    _ => "main".to_string(), // Default fallback
+                };
+                
+                this.update(cx, |_this, cx| {
+                    let url = if current_branch != default_branch_output && !current_branch.is_empty() {
+                        format!("https://github.com/{}/{}/compare/{}...{}", 
+                            remote.owner.as_ref(), remote.repo.as_ref(), 
+                            default_branch_output, current_branch)
+                    } else {
+                        format!("https://github.com/{}/{}/compare", 
+                            remote.owner.as_ref(), remote.repo.as_ref())
+                    };
+                    cx.open_url(&url);
+                })?;
+                
+                Ok::<(), anyhow::Error>(())
+            }).detach_and_log_err(cx);
+        }
+    }
+
+    fn filtered_pull_requests(&self, cx: &App) -> Vec<PullRequest> {
+        let store = self.manager.read(cx).store().read(cx);
+        store
+            .pull_requests()
+            .into_iter()
+            .filter(|pr| {
+                let state_filter = match pr.state {
+                    PullRequestState::Open => self.filter_state.show_open,
+                    PullRequestState::Closed => self.filter_state.show_closed,
+                    PullRequestState::Merged => self.filter_state.show_merged,
+                };
+                state_filter && (!pr.draft || self.filter_state.show_drafts)
+            })
+            .cloned()
+            .collect()
+    }
+
+    fn select_next(&mut self, _: &SelectNext, _window: &mut Window, cx: &mut Context<Self>) {
+        let prs = self.filtered_pull_requests(cx);
+        if !prs.is_empty() {
+            self.selected_index = (self.selected_index + 1) % prs.len();
+            cx.notify();
+        }
+    }
+
+    fn select_prev(&mut self, _window: &mut Window, cx: &mut Context<Self>) {
+        let prs = self.filtered_pull_requests(cx);
+        if !prs.is_empty() {
+            if self.selected_index == 0 {
+                self.selected_index = prs.len() - 1;
+            } else {
+                self.selected_index -= 1;
+            }
+            cx.notify();
+        }
+    }
+
+    fn increase_font_size(
+        &mut self,
+        action: &IncreaseBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        log::info!("PR panel: increase_font_size called, persist={}", action.persist);
+        if !action.persist {
+            theme::adjust_buffer_font_size(cx, |size| {
+                let new_size = size + px(1.0);
+                log::info!("PR panel: Adjusting font size from {} to {}", size.0, new_size.0);
+                new_size
+            });
+            cx.notify();
+            log::info!("PR panel: Font size increased and notify called");
+        }
+    }
+
+    fn decrease_font_size(
+        &mut self,
+        action: &DecreaseBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        log::info!("PR panel: decrease_font_size called, persist={}", action.persist);
+        if !action.persist {
+            theme::adjust_buffer_font_size(cx, |size| {
+                let new_size = size - px(1.0);
+                log::info!("PR panel: Adjusting font size from {} to {}", size.0, new_size.0);
+                new_size
+            });
+            cx.notify();
+            log::info!("PR panel: Font size decreased and notify called");
+        }
+    }
+
+    fn reset_font_size(
+        &mut self,
+        action: &ResetBufferFontSize,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        if !action.persist {
+            theme::reset_buffer_font_size(cx);
+            cx.notify();
+        }
+    }
+}
+
+impl Render for PullRequestListPanel {
+    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
+        let pr_count = self.filtered_pull_requests(cx).len();
+        log::info!("Rendering PullRequestListPanel with {} PRs", pr_count);
+        let store = self.manager.read(cx).store().read(cx);
+        let prs = self.filtered_pull_requests(cx);
+
+        v_flex()
+            .size_full()
+            .child(
+                h_flex()
+                    .gap_2()
+                    .p_2()
+                    .border_b_1()
+                    .border_color(cx.theme().colors().border)
+                    .child(
+                        h_flex()
+                            .gap_1()
+                            .flex_1()
+                            .child(Label::new("Pull Requests").size(LabelSize::Small)),
+                    )
+                    .child(
+                        IconButton::new("refresh", IconName::Rerun)
+                            .icon_size(IconSize::Small)
+                            .disabled({
+                                // Disable if no repository or not authenticated
+                                self.manager.read(cx).get_current_remote(cx).is_err() || !GithubAuth::global(cx).is_authenticated()
+                            })
+                            .on_click(cx.listener(|this, _, window, cx| {
+                                this.refresh_pull_requests(&RefreshPullRequests, window, cx);
+                            }))
+                            .tooltip(Tooltip::text("Refresh Pull Requests")),
+                    )
+                    .child(
+                        IconButton::new("create-pr", IconName::Plus)
+                            .icon_size(IconSize::Small)
+                            .disabled(self.manager.read(cx).get_current_remote(cx).is_err())
+                            .on_click(cx.listener(|this, _, window, cx| {
+                                this.create_pull_request(window, cx);
+                            }))
+                            .tooltip(Tooltip::text("Create Pull Request")),
+                    ),
+            )
+            .child(
+                div()
+                    .flex_1()
+                    .track_focus(&self.focus_handle)
+                    .on_action(cx.listener(|this, action: &IncreaseBufferFontSize, _window, cx| {
+                        log::info!("PR panel: IncreaseBufferFontSize action received");
+                        this.increase_font_size(action, _window, cx);
+                    }))
+                    .on_action(cx.listener(|this, action: &DecreaseBufferFontSize, _window, cx| {
+                        log::info!("PR panel: DecreaseBufferFontSize action received");
+                        this.decrease_font_size(action, _window, cx);
+                    }))
+                    .on_action(cx.listener(|this, action: &ResetBufferFontSize, _window, cx| {
+                        log::info!("PR panel: ResetBufferFontSize action received");
+                        this.reset_font_size(action, _window, cx);
+                    }))
+                    .on_action(cx.listener(Self::select_next))
+                    .on_action(cx.listener(Self::checkout_pull_request))
+                    .on_action(cx.listener(Self::open_in_browser))
+                    .on_action(cx.listener(Self::copy_url))
+                    .on_action(cx.listener(Self::refresh_pull_requests))
+                    .key_context("PullRequestListPanel")
+                    .child(if self.is_loading || store.is_loading() {
+                        div()
+                            .p_4()
+                            .child(Label::new("Loading pull requests...").color(Color::Muted))
+                    } else if let Some(error) = store.error() {
+                        let error_message = error.to_string();
+                        let is_auth_error = error_message.contains("404") || 
+                                           error_message.contains("401") ||
+                                           error_message.contains("403");
+                        
+                        div()
+                            .p_4()
+                            .child(
+                                v_flex()
+                                    .gap_2()
+                                    .child(
+                                        Label::new(SharedString::from(error_message))
+                                            .color(Color::Error)
+                                    )
+                                    .when(is_auth_error, |this| {
+                                        this.child(
+                                            ui::Button::new("login", "Login with GitHub")
+                                                .on_click(cx.listener(|this, _, _window, cx| {
+                                                    this.login_with_github(&LoginWithGithub, cx);
+                                                }))
+                                        )
+                                    })
+                            )
+                    } else if prs.is_empty() {
+                        let auth_state = GithubAuth::global(cx);
+                        if !auth_state.is_authenticated() {
+                            div()
+                                .p_4()
+                                .child(
+                                    v_flex()
+                                        .gap_2()
+                                        .child(
+                                            Label::new("GitHub authentication required to view pull requests")
+                                                .color(Color::Muted)
+                                        )
+                                        .child(
+                                            ui::Button::new("login", "Login with GitHub")
+                                                .on_click(cx.listener(|this, _, _window, cx| {
+                                                    this.login_with_github(&LoginWithGithub, cx);
+                                                }))
+                                        )
+                                )
+                        } else {
+                            // Check if there's a valid git repository
+                            if let Ok(_remote) = self.manager.read(cx).get_current_remote(cx) {
+                                div()
+                                    .p_4()
+                                    .child(Label::new("No pull requests found").color(Color::Muted))
+                            } else {
+                                div()
+                                    .p_4()
+                                    .child(
+                                        v_flex()
+                                            .gap_2()
+                                            .child(
+                                                Label::new("No Git repository detected")
+                                                    .color(Color::Muted)
+                                            )
+                                            .child(
+                                                Label::new("Open a project with a Git repository to view pull requests")
+                                                    .color(Color::Muted)
+                                                    .size(LabelSize::Small)
+                                            )
+                                    )
+                            }
+                        }
+                    } else {
+                        let selected_index = self.selected_index;
+                        
+                        div()
+                            .size_full()
+                            .child(
+                                v_flex()
+                                    .children(prs.iter().enumerate().map(move |(idx, pr)| {
+                            let is_selected = idx == selected_index;
+
+                            let state_icon = match pr.state {
+                                PullRequestState::Open => {
+                                    if pr.draft {
+                                        Icon::new(IconName::GitBranch)
+                                            .color(Color::Modified)
+                                            .size(IconSize::Small)
+                                    } else {
+                                        Icon::new(IconName::GitBranch)
+                                            .color(Color::Success)
+                                            .size(IconSize::Small)
+                                    }
+                                }
+                                PullRequestState::Closed => Icon::new(IconName::Close)
+                                    .color(Color::Error)
+                                    .size(IconSize::Small),
+                                PullRequestState::Merged => Icon::new(IconName::Check)
+                                    .color(Color::Accent)
+                                    .size(IconSize::Small),
+                            };
+
+                            let title = SharedString::from(pr.title.clone());
+                            let total_comments = pr.comments + pr.review_comments;
+                            let subtitle = SharedString::from(format!(
+                                "#{} opened by {} • {} comments",
+                                pr.number, pr.user.login, total_comments
+                            ));
+
+                            let pr_clone = pr.clone();
+                            
+                            ListItem::new(SharedString::from(format!("pr-{}", pr.number)))
+                                .spacing(ListItemSpacing::Sparse)
+                                .toggle_state(is_selected)
+                                .on_click(cx.listener(move |this, _, window, cx| {
+                                    this.selected_index = idx;
+                                    this.open_pr_detail(pr_clone.clone(), window, cx);
+                                    cx.notify();
+                                }))
+                                .child(
+                                    h_flex().gap_2().child(state_icon).child(
+                                        v_flex().gap_1().child(Label::new(title)).child(
+                                            Label::new(subtitle)
+                                                .color(Color::Muted)
+                                                .size(LabelSize::Small),
+                                        ),
+                                    ),
+                                )
+                        })))
+                    }),
+            )
+    }
+}
+
+impl Focusable for PullRequestListPanel {
+    fn focus_handle(&self, _cx: &App) -> FocusHandle {
+        self.focus_handle.clone()
+    }
+}
+
+impl Panel for PullRequestListPanel {
+    fn persistent_name() -> &'static str {
+        "PullRequestListPanel"
+    }
+
+    fn position(&self, _window: &Window, cx: &App) -> DockPosition {
+        match PullRequestListPanelSettings::get_global(cx).dock {
+            PullRequestListPanelDockPosition::Left => DockPosition::Left,
+            PullRequestListPanelDockPosition::Right => DockPosition::Right,
+        }
+    }
+
+    fn position_is_valid(&self, position: DockPosition) -> bool {
+        matches!(position, DockPosition::Left | DockPosition::Right)
+    }
+
+    fn set_position(
+        &mut self,
+        position: DockPosition,
+        _window: &mut Window,
+        cx: &mut Context<Self>,
+    ) {
+        settings::update_settings_file::<PullRequestListPanelSettings>(
+            self.fs.clone(),
+            cx,
+            move |settings, _| {
+                let dock = match position {
+                    DockPosition::Left => PullRequestListPanelDockPosition::Left,
+                    DockPosition::Right => PullRequestListPanelDockPosition::Right,
+                    _ => return,
+                };
+                settings.dock = dock;
+            },
+        );
+    }
+
+    fn size(&self, _window: &Window, _cx: &App) -> Pixels {
+        px(300.0)
+    }
+
+    fn set_size(&mut self, _size: Option<Pixels>, _window: &mut Window, _cx: &mut Context<Self>) {
+        // Size is fixed for now
+    }
+    
+    fn set_active(&mut self, active: bool, window: &mut Window, cx: &mut Context<Self>) {
+        log::info!("PullRequestListPanel::set_active called with active={}", active);
+        
+        if active {
+            // Focus the panel when it becomes active
+            self.focus_handle.focus(window);
+        }
+        
+        if !active {
+            // Reset auto-fetch flag when panel becomes inactive so it will fetch again next time
+            self.has_auto_fetched = false;
+            log::info!("Panel deactivated, reset has_auto_fetched");
+        } else if active && !self.has_auto_fetched {
+            if GithubAuth::global(cx).is_authenticated() {
+                log::info!("Panel activated and authenticated, starting auto-fetch");
+                self.has_auto_fetched = true;
+                self.is_loading = true;
+                
+                // Get the actual project's working directory
+                let project = self.project.clone();
+                let cwd = project.read(cx)
+                    .worktrees(cx)
+                    .next()
+                    .and_then(|worktree| {
+                        let worktree = worktree.read(cx);
+                        worktree.root_entry()
+                            .filter(|entry| entry.is_dir())
+                            .map(|_| worktree.abs_path().to_path_buf())
+                    });
+                
+                let Some(cwd) = cwd else {
+                    log::warn!("PR panel: No project directory found");
+                    self.is_loading = false;
+                    cx.notify();
+                    return;
+                };
+                
+                log::info!("PR panel: Project directory: {:?}", cwd);
+                
+                // Detect repository from project's directory
+                let manager = self.manager.clone();
+                cx.spawn(async move |this, cx| {
+                
+                // Get origin remote first to determine the actual repository
+                let origin_url = if let Ok(output) = new_smol_command("git")
+                    .current_dir(&cwd)
+                    .args(&["remote", "get-url", "origin"])
+                    .output()
+                    .await
+                {
+                    if output.status.success() {
+                        let url = String::from_utf8_lossy(&output.stdout).trim().to_string();
+                        log::info!("PR panel: Git origin URL: {}", url);
+                        url
+                    } else {
+                        log::warn!("PR panel: Git command failed");
+                        String::new()
+                    }
+                } else {
+                    log::warn!("PR panel: Failed to execute git remote command");
+                    String::new()
+                };
+                
+                // Use origin by default
+                let mut remote_url = origin_url.clone();
+                
+                // Only check upstream if this appears to be a Zed fork
+                // Be specific: only match URLs ending with /zed or /zed.git
+                let is_zed_fork = !origin_url.is_empty() && 
+                   !origin_url.contains("zed-industries") &&
+                   (origin_url.ends_with("/zed.git") || 
+                    origin_url.ends_with("/zed") ||
+                    origin_url.contains(":zed.git") ||
+                    origin_url.contains(":zed"));
+                    
+                if is_zed_fork {
+                    log::info!("Detected Zed fork (origin: {}), checking for upstream remote", origin_url);
+                    // This is a Zed fork, try to use upstream
+                    if let Ok(output) = new_smol_command("git")
+                        .current_dir(&cwd)
+                        .args(&["remote", "get-url", "upstream"])
+                        .output()
+                        .await
+                    {
+                        if output.status.success() {
+                            let upstream_url = String::from_utf8_lossy(&output.stdout).trim().to_string();
+                            if !upstream_url.is_empty() && upstream_url.contains("zed-industries/zed") {
+                                log::info!("Using upstream remote: {}", upstream_url);
+                                remote_url = upstream_url;
+                            }
+                        }
+                    }
+                }
+                
+                // If still no remote found, mark loading as complete
+                if remote_url.is_empty() {
+                    this.update(cx, |this, cx| {
+                        this.is_loading = false;
+                        cx.notify();
+                    })?;
+                    return Ok::<(), anyhow::Error>(());
+                }
+                
+                // Parse the remote URL to get owner/repo
+                log::info!("PR panel: Attempting to parse remote URL: {}", remote_url);
+                let parsed_remote = this.update(cx, |_this, cx| {
+                    let provider_registry = GitHostingProviderRegistry::global(cx);
+                    let result = parse_git_remote_url(provider_registry, &remote_url)
+                        .map(|(_provider, parsed_remote)| parsed_remote);
+                    if let Some(ref remote) = result {
+                        log::info!("PR panel: Successfully parsed - owner: {}, repo: {}", 
+                            remote.owner.as_ref(), remote.repo.as_ref());
+                    } else {
+                        log::warn!("PR panel: Failed to parse remote URL");
+                    }
+                    result
+                })?;
+                
+                if let Some(remote) = parsed_remote {
+                    // Log what we're fetching
+                    log::info!("Auto-fetching PRs for {}/{}", remote.owner.as_ref(), remote.repo.as_ref());
+                    
+                    // Fetch PRs directly from the detected repository (including Zed)
+                    let _ = manager.update(cx, |manager, cx| {
+                        manager.store().update(cx, |store, cx| {
+                            store.fetch_pull_requests(remote, cx)
+                        })
+                    })?;
+                } else {
+                    log::warn!("Failed to parse remote URL: {}", remote_url);
+                }
+                
+                // Mark loading as complete after fetch attempt
+                this.update(cx, |this, cx| {
+                    this.is_loading = false;
+                    cx.notify();
+                })?;
+                
+                Ok::<(), anyhow::Error>(())
+            }).detach_and_log_err(cx);
+            } else {
+                log::info!("Panel activated but not authenticated, skipping auto-fetch");
+            }
+        } else if active {
+            log::info!("Panel activated but has_auto_fetched={}, skipping", self.has_auto_fetched);
+        }
+    }
+
+    fn icon(&self, _window: &Window, _cx: &App) -> Option<IconName> {
+        Some(IconName::PullRequest)
+    }
+
+    fn icon_tooltip(&self, _window: &Window, _cx: &App) -> Option<&'static str> {
+        Some("Pull Requests")
+    }
+
+    fn toggle_action(&self) -> Box<dyn gpui::Action> {
+        Box::new(ToggleFocus)
+    }
+
+    fn activation_priority(&self) -> u32 {
+        0
+    }
+    
+}
+
+impl EventEmitter<PanelEvent> for PullRequestListPanel {}
+impl EventEmitter<DismissEvent> for PullRequestListPanel {}
+
+#[derive(Clone, Default, Serialize, Deserialize, JsonSchema, SettingsUi, SettingsKey)]
+#[settings_key(key = "pull_request_panel")]
+pub struct PullRequestListPanelSettings {
+    pub dock: PullRequestListPanelDockPosition,
+}
+
+#[derive(Clone, Debug, Serialize, Deserialize, JsonSchema, SettingsUi)]
+#[serde(rename_all = "lowercase")]
+pub enum PullRequestListPanelDockPosition {
+    Left,
+    Right,
+}
+
+impl Default for PullRequestListPanelDockPosition {
+    fn default() -> Self {
+        Self::Left
+    }
+}
+
+impl Settings for PullRequestListPanelSettings {
+    type FileContent = Self;
+
+    fn load(sources: SettingsSources<'_, Self::FileContent>, _cx: &mut App) -> Result<Self> {
+        sources.json_merge()
+    }
+
+    fn import_from_vscode(_vscode: &settings::VsCodeSettings, _current: &mut Self::FileContent) {}
+}
+
+use util::ResultExt;
\ No newline at end of file
diff --git a/crates/pull_requests_ui/src/pull_requests_ui.rs b/crates/pull_requests_ui/src/pull_requests_ui.rs
new file mode 100644
index 0000000000..3739a9d216
--- /dev/null
+++ b/crates/pull_requests_ui/src/pull_requests_ui.rs
@@ -0,0 +1,20 @@
+// pub mod create_pr_modal; // Temporarily disabled - needs API updates
+// pub mod pr_detail_panel;
+pub mod pr_detail_view;
+pub mod pr_list_panel;
+
+use gpui::App;
+use settings::Settings;
+
+// pub use create_pr_modal::CreatePrModal;
+// pub use pr_detail_panel::PullRequestDetailPanel;
+pub use pr_detail_view::PullRequestDetailView;
+pub use pr_list_panel::{PullRequestListPanel, PullRequestListPanelSettings};
+
+pub fn init(cx: &mut App) {
+    eprintln!("PULL_REQUESTS_UI_INIT: Initializing pull_requests_ui module");
+    PullRequestListPanelSettings::register(cx);
+    pr_list_panel::init(cx);
+    pr_detail_view::init(cx);
+    eprintln!("PULL_REQUESTS_UI_INIT: Done initializing pull_requests_ui module");
+}
diff --git a/crates/zed/Cargo.toml b/crates/zed/Cargo.toml
index f2295d5fa7..7e8ebdecfb 100644
--- a/crates/zed/Cargo.toml
+++ b/crates/zed/Cargo.toml
@@ -118,6 +118,8 @@ project_panel.workspace = true
 project_symbols.workspace = true
 prompt_store.workspace = true
 proto.workspace = true
+pull_requests.workspace = true
+pull_requests_ui.workspace = true
 recent_projects.workspace = true
 release_channel.workspace = true
 remote.workspace = true
diff --git a/crates/zed/src/main.rs b/crates/zed/src/main.rs
index 9582e7a2ab..5d1a79b6fb 100644
--- a/crates/zed/src/main.rs
+++ b/crates/zed/src/main.rs
@@ -612,6 +612,8 @@ pub fn main() {
         project_symbols::init(cx);
         project_panel::init(cx);
         outline_panel::init(cx);
+        pull_requests::init(cx);
+        pull_requests_ui::init(cx);
         tasks_ui::init(cx);
         snippets_ui::init(cx);
         channel::init(&app_state.client.clone(), app_state.user_store.clone(), cx);
@@ -628,6 +630,8 @@ pub fn main() {
         notifications::init(app_state.client.clone(), app_state.user_store.clone(), cx);
         collab_ui::init(&app_state, cx);
         git_ui::init(cx);
+        pull_requests::init(cx);
+        pull_requests_ui::init(cx);
         jj_ui::init(cx);
         feedback::init(cx);
         markdown_preview::init(cx);
diff --git a/crates/zed/src/zed.rs b/crates/zed/src/zed.rs
index 96f0f261dc..a0384bc3a0 100644
--- a/crates/zed/src/zed.rs
+++ b/crates/zed/src/zed.rs
@@ -550,6 +550,8 @@ fn initialize_panels(
         let outline_panel = OutlinePanel::load(workspace_handle.clone(), cx.clone());
         let terminal_panel = TerminalPanel::load(workspace_handle.clone(), cx.clone());
         let git_panel = GitPanel::load(workspace_handle.clone(), cx.clone());
+        let pr_list_panel =
+            pull_requests_ui::PullRequestListPanel::load(workspace_handle.clone(), cx.clone());
         let channels_panel =
             collab_ui::collab_panel::CollabPanel::load(workspace_handle.clone(), cx.clone());
         let chat_panel =
@@ -565,6 +567,7 @@ fn initialize_panels(
             outline_panel,
             terminal_panel,
             git_panel,
+            pr_list_panel,
             channels_panel,
             chat_panel,
             notification_panel,
@@ -574,6 +577,7 @@ fn initialize_panels(
             outline_panel,
             git_panel,
             terminal_panel,
+            pr_list_panel,
             channels_panel,
             chat_panel,
             notification_panel,
@@ -585,6 +589,7 @@ fn initialize_panels(
             workspace.add_panel(outline_panel, window, cx);
             workspace.add_panel(terminal_panel, window, cx);
             workspace.add_panel(git_panel, window, cx);
+            workspace.add_panel(pr_list_panel, window, cx);
             workspace.add_panel(channels_panel, window, cx);
             workspace.add_panel(chat_panel, window, cx);
             workspace.add_panel(notification_panel, window, cx);
